<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

<channel>
	<title>NixOS Planet</title>
	<link>https://planet.nixos.org</link>
	<language>en</language>
	<description>NixOS Planet - https://planet.nixos.org</description>
	<atom:link rel="self" href="https://planet.nixos.org/rss20.xml" type="application/rss+xml"/>

<item>
	<title>Tweag I/O: Trustix: Distributed trust and reproducibility tracking for binary caches</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-12-16-trustix-announcement/</guid>
	<link>https://tweag.io/blog/2020-12-16-trustix-announcement/</link>
	<description>&lt;p&gt;Downloading binaries from well-known providers is the easiest way to install new software.
After all, building software from source is a chore — it requires both time and technical expertise.
But how do we know that we aren’t installing something malicious from these providers?&lt;/p&gt;
&lt;p&gt;Typically, we trust these binaries because we trust the provider.
We believe that they were built from trusted sources, in a trusted computational environment, and with trusted build instructions.
But even if the provider does everything transparently and in good faith, the binaries could still be &lt;em&gt;anything&lt;/em&gt; if the provider’s system is compromised.
In other words, the build process requires &lt;em&gt;trust&lt;/em&gt; even if all build inputs (sources, dependencies, build scripts, etc…) are known.&lt;/p&gt;
&lt;p&gt;Overcoming this problem is hard — after all, how can we verify the output of arbitrary build inputs?
Excitingly, the last years have brought about ecosystems such as Nix, where all build inputs are known and where &lt;em&gt;significant amounts of builds are reproducible&lt;/em&gt;.
This means that the correspondence between inputs and outputs can be verified by building the same binary multiple times!
The &lt;a href=&quot;https://r13y.com/&quot;&gt;r13y&lt;/a&gt; project, for example, tracks non-reproducible builds by building them twice on the same machine, showing that this is indeed practical.&lt;/p&gt;
&lt;p&gt;But we can go further, and that’s the subject of this blog post, which introduces &lt;a href=&quot;https://github.com/tweag/trustix&quot;&gt;Trustix&lt;/a&gt;, a new tool we are working on.
Trustix compares build outputs for given build inputs across &lt;em&gt;independent&lt;/em&gt; providers and machines, effectively decentralizing trust.
This establishes what I like to call &lt;a href=&quot;https://build-transparency.org&quot;&gt;build transparency&lt;/a&gt; because it verifies what black box build machines are doing.
Behind the scenes Trustix builds a &lt;a href=&quot;https://en.wikipedia.org/wiki/Merkle_tree&quot;&gt;Merkle tree&lt;/a&gt;-based &lt;a href=&quot;https://en.wikipedia.org/wiki/Append-only&quot;&gt;append-only&lt;/a&gt; log that maps build inputs to build outputs, which I’ll come back to in a later post.
This log can be used to establish &lt;a href=&quot;https://en.wikipedia.org/wiki/Consensus_(computer_science)&quot;&gt;consensus&lt;/a&gt; whether certain build inputs always produce the same output — and can therefore be trusted.
Conversely, it can also be used to uncover non-reproducible builds, corrupted or not, on a large scale.&lt;/p&gt;
&lt;p&gt;The initial implementation of Trustix, and its description in this post are based on the Nix package manager.
Nix focuses on isolated builds, provides access to the hashes of all build inputs as well as a high quantity of bit-reproducible packages, making it the ideal initial testing ecosystem.
However, Trustix was designed to be system-independent, and is not strongly tied to Nix.&lt;/p&gt;
&lt;p&gt;The developmentent of &lt;a href=&quot;https://github.com/tweag/trustix&quot;&gt;Trustix&lt;/a&gt; is funded by &lt;a href=&quot;https://nlnet.nl/project/Trustix&quot;&gt;NLnet foundation&lt;/a&gt; and the European Commission’s &lt;a href=&quot;https://ngi.eu&quot;&gt;Next Generation Internet&lt;/a&gt; programme through the &lt;a href=&quot;https://nlnet.nl/PET&quot;&gt;NGI Zero PET&lt;/a&gt; (privacy and trust enhancing technologies) fund.
The tool is still in development, but I’m very excited to announce it already!&lt;/p&gt;
&lt;h2&gt;How Nix verifies binary cache results&lt;/h2&gt;
&lt;p&gt;Most Linux package managers use a very simple signature scheme to secure binary distribution to users.
Some use GPG keys, some use OpenSSL certificates, and others use some other kind of key, but the idea is essentially the same for all of them.
The general approach is that binaries are signed with a private key, and clients can use an associated public key to check that a binary was really signed by the trusted entity.&lt;/p&gt;
&lt;p&gt;Nix for example uses an ed25519-based key signature scheme and comes with a default hard-coded public key that corresponds to the default cache.
This key can be overridden or complemented by others, allowing the use of additional caches.
The list of signing keys can be found in &lt;code class=&quot;language-text&quot;&gt;/etc/nix/nix.conf&lt;/code&gt;.
The default base64-encoded ed25519 public key with a name as additional metadata looks like this:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY=&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, in Nix, software is addressed by the hash of all of its build inputs (sources, dependencies and build instructions).
This hash, or the output path is used to query a cache (like &lt;a href=&quot;https://cache.nixos.org&quot;&gt;https://cache.nixos.org&lt;/a&gt;) for a binary.&lt;/p&gt;
&lt;p&gt;Here is an example:
The hash of the &lt;code class=&quot;language-text&quot;&gt;hello&lt;/code&gt; derivation can be obtained from a shell with &lt;code class=&quot;language-text&quot;&gt;nix-instantiate&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ nix-instantiate '&amp;lt;nixpkgs&amp;gt;' --eval -A hello.outPath
&quot;/nix/store/w9yy7v61ipb5rx6i35zq1mvc2iqfmps1-hello-2.10&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, behind the scenes, we have evaluated and hashed all build inputs that the &lt;code class=&quot;language-text&quot;&gt;hello&lt;/code&gt; derivation needs (&lt;code class=&quot;language-text&quot;&gt;.outPath&lt;/code&gt; is just a helper).
This hash can then be used to query the default Nix binary cache:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ curl https://cache.nixos.org/w9yy7v61ipb5rx6i35zq1mvc2iqfmps1.narinfo
StorePath: /nix/store/w9yy7v61ipb5rx6i35zq1mvc2iqfmps1-hello-2.10
URL: nar/15zk4zszw9lgkdkkwy7w11m5vag11n5dhv2i6hj308qpxczvdddx.nar.xz
Compression: xz
FileHash: sha256:15zk4zszw9lgkdkkwy7w11m5vag11n5dhv2i6hj308qpxczvdddx
FileSize: 41232
NarHash: sha256:1mi14cqk363wv368ffiiy01knardmnlyphi6h9xv6dkjz44hk30i
NarSize: 205968
References: 9df65igwjmf2wbw0gbrrgair6piqjgmi-glibc-2.31 w9yy7v61ipb5rx6i35zq1mvc2iqfmps1-hello-2.10
Sig: cache.nixos.org-1:uP5KU8MCmyRnKGlN5oEv6xWJBI5EO/Pf5aFztZuLSz8BpCcZ1fdBnJkVXhBAlxkdm/CemsgQskhwvyd2yghTAg==&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Besides links to the archive that contains the compressed binaries, this response includes two relevant pieces of information which are used to verify binaries from the binary cache(s):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code class=&quot;language-text&quot;&gt;NarHash&lt;/code&gt; is a hash over all Nix store directory contents&lt;/li&gt;
&lt;li&gt;The &lt;code class=&quot;language-text&quot;&gt;Sig&lt;/code&gt; is a cryptographic signature over the &lt;code class=&quot;language-text&quot;&gt;NarHash&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With this information, the client can check that this binary really comes from the provider’s Nix store.&lt;/p&gt;
&lt;h2&gt;What are the limitations of this model?&lt;/h2&gt;
&lt;p&gt;While this model has served Nix and others well for many years it suffers from a few problems.
All of these problems can be traced back to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_point_of_failure&quot;&gt;single point of failure&lt;/a&gt; in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Chain_of_trust&quot;&gt;chain of trust&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First, if the key used by cache.nixos.org is ever compromised, all builds that were ever added to the cache can be considered tainted.&lt;/li&gt;
&lt;li&gt;Second, one needs to put either full trust or no trust at all in the build machines of a binary cache — there is no middle ground.&lt;/li&gt;
&lt;li&gt;Finally, there is no inherent guarantee that the build inputs described in the Nix expressions were actually used to build what’s in the cache.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Trustix&lt;/h2&gt;
&lt;p&gt;Trustix aims to solve these problems by assembling a mapping from build inputs to (hashes of) build outputs provided by many build machines.&lt;/p&gt;
&lt;p&gt;Instead of relying on verifying packages signatures, like the traditional Nix model does, Trustix only exposes packages that it considers trustworthy.
Concretely, Trustix is configured as a proxy for a binary cache, and hides the packages which are not trustworthy.
As far as Nix is concerned, the package not being trustworthy is exactly as if the package wasn’t stored in the binary cache to begin with.
If such a package is required, Nix will therefore build it from source.&lt;/p&gt;
&lt;p&gt;Trustix doesn’t define what a trustworthy package is.
What your Trustix considers trustworthy is up to you.
The rules for accepting packages are entirely configurable.
In fact, in the current prototype, there isn’t a default rule for packages to count as trustworthy: you need to configure trustworthiness yourself.&lt;/p&gt;
&lt;p&gt;With this in mind, let’s revisit the above issues&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In Trustix, if an entity is compromised, you can rely on all
other entities in the network to establish that a binary artefact is
trustworthy. Maybe a few hashes are wrong in the Trustix mapping,
but if an overwhelming majority of the outputs are the same, you can
trust that the corresponding artefact is indeed what you would have
built yourself.&lt;/p&gt;
&lt;p&gt;Therefore you never need to invalidate an entire binary cache: you
can still verify the trustworthiness of old packages, even if newer
packages are built by a malicious actor.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In Trustix, you never typically consider any build machine to be
fully trusted. You always check their results against the other
build machines. You can further configure this by considering some
machines as more trusted (maybe because it is a community-operated
machine, and you trust said community) or less trusted (for instance,
because it has been compromised in the past, and you fear it may be
compromised again).&lt;/p&gt;
&lt;p&gt;Moreover, in the spirit of having no single point of failure,
Trustix’s mapping is not kept in a central database. Instead every
builder keeps a log of its builds; these logs are aggregated on your
machine by your instance of the Trustix daemon. Therefore even the
mapping itself doesn’t have to be fully trusted.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;In Trustix, package validity is not ensured by a signature scheme.
Instead Trustix relies on the consistency of the input to output
mapping. As a consequence, the validity criterion, contrary to a
signature scheme, links the output to the input. It makes it
infeasible to pass the build result of input &lt;code class=&quot;language-text&quot;&gt;I&lt;/code&gt; as a build result for
input &lt;code class=&quot;language-text&quot;&gt;J&lt;/code&gt;: it would require corrupting the entire network.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Limitations: reproducibility tracking and non-reproducible builds&lt;/h2&gt;
&lt;p&gt;A system like Trustix will not work well with builds that are non-reproducible, which is a limitation of this model.
After all, you cannot reach consensus if everyone’s opinions differ.&lt;/p&gt;
&lt;p&gt;However, Trustix can still be useful, even for non-reproducible builds!
By accumulating all the data in the various logs and aggregating them, we can track which derivations are non-reproducible over all of Nixpkgs, in a way that is easier than previously possible.
Whereas the &lt;a href=&quot;https://r13y.com/&quot;&gt;r13y project&lt;/a&gt; builds a single closure
on a single machine, Trustix will index &lt;em&gt;everything ever built&lt;/em&gt; on every
architecture.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I am very excited to be working on the next generation of tooling for trust and reproducibility, and for the purely functional software packaging model pioneered by Nix to keep enabling new use cases.
I hope that this work can be a foundation for many other applications other than improving trust — for example, by enabling the Nix community to support new CPU architectures with community binary caches.&lt;/p&gt;
&lt;p&gt;Please check out the code at the &lt;a href=&quot;https://github.com/tweag/trustix&quot;&gt;repo&lt;/a&gt; or join us for a chat over in &lt;code class=&quot;language-text&quot;&gt;#untrustix&lt;/code&gt; on &lt;a href=&quot;https://webchat.freenode.net/&quot;&gt;Freenode&lt;/a&gt;.
And stay tuned — in the next blog post, we will talk more about Merkle trees and how they are used in Trustix.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nlnet.nl/&quot;&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;display: block; margin-left: auto; margin-right: auto;&quot;&gt;
      &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;display: block;&quot;&gt;&lt;/span&gt;
  &lt;img alt=&quot;NLNet&quot; class=&quot;gatsby-resp-image-image&quot; src=&quot;https://www.tweag.io/static/efbf832b18623ce0246865138f7e61e9/fc2a6/nlnet-banner.png&quot; style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle;&quot; title=&quot;NLNet&quot; /&gt;
    &lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nlnet.nl/NGI0&quot;&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;display: block; margin-left: auto; margin-right: auto;&quot;&gt;
      &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;display: block;&quot;&gt;&lt;/span&gt;
  &lt;img alt=&quot;NGI0&quot; class=&quot;gatsby-resp-image-image&quot; src=&quot;https://www.tweag.io/static/b817c1323bb0eb39e2cace92a3e9a410/9b7bd/NGI0_tag.png&quot; style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle;&quot; title=&quot;NGI0&quot; /&gt;
    &lt;/span&gt;&lt;/a&gt;&lt;/p&gt;</description>
	<pubDate>Wed, 16 Dec 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Tweag I/O: Self-references in a content-addressed Nix</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-11-18-nix-cas-self-references/</guid>
	<link>https://tweag.io/blog/2020-11-18-nix-cas-self-references/</link>
	<description>&lt;p&gt;In a &lt;a href=&quot;https://www.tweag.io/blog/2020-09-10-nix-cas/&quot;&gt;previous post&lt;/a&gt; I explained why we were eagerly trying to change the Nix store model to allow for content-addressed derivations.
I also handwaved that this was a real challenge, but without giving any hint at &lt;strong&gt;why&lt;/strong&gt; this could be tricky.
So let’s dive a bit into the gory details and understand some of the conceptual pain points with content-addressability in Nix, which forced us to some trade-offs in how we handle content-addressed paths.&lt;/p&gt;
&lt;h1&gt;What are self-references?&lt;/h1&gt;
&lt;p&gt;&lt;a name=&quot;self&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a self-reference&lt;/p&gt;
&lt;p&gt;— &lt;cite&gt;Théophane Hufschmitt, &lt;a href=&quot;https://www.tweag.io/rss-nix.xml#self&quot;&gt;This very article&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A very trivial Nix derivation might look like this:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;nixpkgs&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
writeScript &lt;span class=&quot;token string&quot;&gt;&quot;hello&quot;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;''
#!&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token antiquotation variable&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;bash&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;/bin/bash

${hello}/bin/hello
''&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The result of this derivation will be an executable file containing a script that will run the &lt;code class=&quot;language-text&quot;&gt;hello&lt;/code&gt; program.
It will depend on the &lt;code class=&quot;language-text&quot;&gt;bash&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;hello&lt;/code&gt; derivations as we refer to them in the file.&lt;/p&gt;
&lt;p&gt;We can build this derivation and execute it:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ nix-build hello.nix
$ ./result
Hello, world!&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So far, so good.
Let’s now change our derivation to change the prompt of &lt;code class=&quot;language-text&quot;&gt;hello&lt;/code&gt; to something more personalized:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;nixpkgs&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
writeScript &lt;span class=&quot;token string&quot;&gt;&quot;hello-its-me&quot;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;''
#!&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token antiquotation variable&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;bash&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;/bin/bash

echo &quot;Hello, world! This is &lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token antiquotation variable&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;placeholder &lt;span class=&quot;token string&quot;&gt;&quot;out&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&quot;
''&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where &lt;code class=&quot;language-text&quot;&gt;${placeholder &quot;out&quot;}&lt;/code&gt; is a magic value that will be replaced by the output path of the derivation during the build.&lt;/p&gt;
&lt;p&gt;We can build this and run the result just fine&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ nix-build hello-its-me.nix
$ ./result
Hello, world! This is /nix/store/c0qw0gbp7rfyzm7x7ih279pmnzazg86p-hello-its-me&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And we can check that the file is indeed who it claims to be:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ /nix/store/c0qw0gbp7rfyzm7x7ih279pmnzazg86p-hello-its-me
Hello, world! This is /nix/store/c0qw0gbp7rfyzm7x7ih279pmnzazg86p-hello-its-me&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While the &lt;code class=&quot;language-text&quot;&gt;hello&lt;/code&gt; derivation depends on &lt;code class=&quot;language-text&quot;&gt;bash&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;hello&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;hello-its-me&lt;/code&gt; depends on &lt;code class=&quot;language-text&quot;&gt;bash&lt;/code&gt; and… itself.
This is something rather common in Nix.
For example, it’s rather natural for a C program to have &lt;code class=&quot;language-text&quot;&gt;/nix/store/xxx-foo/bin/foo&lt;/code&gt; depend of &lt;code class=&quot;language-text&quot;&gt;/nix/store/xxx-foo/lib/libfoo.so&lt;/code&gt;.&lt;/p&gt;
&lt;h1&gt;Self references and content-addressed paths&lt;/h1&gt;
&lt;p&gt;How do we build a content-addressed derivation &lt;code class=&quot;language-text&quot;&gt;foo&lt;/code&gt; in Nix? The recipe is rather simple:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Build the derivation in a temporary directory &lt;code class=&quot;language-text&quot;&gt;/some/where/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Compute the hash &lt;code class=&quot;language-text&quot;&gt;xxx&lt;/code&gt; of that &lt;code class=&quot;language-text&quot;&gt;/some/where/&lt;/code&gt; directory&lt;/li&gt;
&lt;li&gt;Move the directory under &lt;code class=&quot;language-text&quot;&gt;/nix/store/xxx-foo/&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You might see where things will go wrong with self-references: the reference will point to &lt;code class=&quot;language-text&quot;&gt;/some/where&lt;/code&gt; rather than &lt;code class=&quot;language-text&quot;&gt;/nix/store/xxx-foo&lt;/code&gt;, and so will be wrong (in addition to leak a path to what should just be a temporary directory).&lt;/p&gt;
&lt;p&gt;To work around that, we would need to compute this &lt;code class=&quot;language-text&quot;&gt;xxx&lt;/code&gt; hash before the build, but that’s quite impossible as the hash depends on the content of the directory, including the value of the self-references.&lt;/p&gt;
&lt;p&gt;However, we can hack our way around it in most cases by allowing ourselves a bit of heuristic.
The only assumption that we need to make is that all the
self-references will appear textually (&lt;em&gt;i.e.&lt;/em&gt; running &lt;code class=&quot;language-text&quot;&gt;strings&lt;/code&gt; on a
file that contains self-references will print all the self-references out).&lt;/p&gt;
&lt;p&gt;Under that assumption, we can:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Build the derivation in our &lt;code class=&quot;language-text&quot;&gt;/some/where&lt;/code&gt; directory&lt;/li&gt;
&lt;li&gt;Replace all the occurrences of a self-reference by a magic value&lt;/li&gt;
&lt;li&gt;Compute the hash of the resulting path to determine the final path&lt;/li&gt;
&lt;li&gt;Replace all the occurrences of the magic value by the final path&lt;/li&gt;
&lt;li&gt;Move the resulting store path to its final path&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now you might think that this is a crazy hack − there’s so many ways it could break.
And in theory you’ll be right.
But, surprisingly, this works remarkably well in practice.
You might also notice that &lt;em&gt;pedantically speaking&lt;/em&gt; this scheme isn’t exactly content-addressing because of the “modulo the final hash” part.
But this is close-enough to keep all the desirable properties of proper content addressing, while also enabling self-references, which wouldn’t be possible otherwise.
For example, the Fugue cloud deployment system used &lt;a href=&quot;https://www.fugue.co/blog/2016-05-18-cryptographic-hashes-and-dependency-cycles.html&quot;&gt;a generalisation
of this technique&lt;/a&gt; which not only deals with
self-references, but with reference cycles of arbitrary length.&lt;/p&gt;
&lt;p&gt;However, there’s a key thing that’s required for this to work: patching strings in binaries is generally benign, but the final string must have the same length as the original one.
But we can do that: we don’t know what the final &lt;code class=&quot;language-text&quot;&gt;xxx&lt;/code&gt; hash will be, but we know its length (because it’s a fixed-length hash), so we can just choose a temporary directory that has the right length (like a temporary store path with the same name), and we’re all set!&lt;/p&gt;
&lt;p&gt;The annoying thing is that there’s no guarantee that there are no self-references hidden in such a way that a textual replacement won’t catch it (for example inside a compressed zip file).
This is the main reason why content-addressability will not be the default in Nix, at first at least.&lt;/p&gt;
&lt;h1&gt;Non-deterministic builds − the diamond problem strikes back&lt;/h1&gt;
&lt;p&gt;No matter how hard Nix tries to isolate the build environment, some actions will remain inherently non-deterministic − anything that can yield a different output depending on the order in which concurrent tasks will be executed for example.
This is an annoyance as it might prevent &lt;em&gt;early cutoff&lt;/em&gt; (see &lt;a href=&quot;https://www.tweag.io/blog/2020-09-10-nix-cas/&quot;&gt;our previous article on the subject&lt;/a&gt; in case you missed it).&lt;/p&gt;
&lt;p&gt;But more than limiting the efficiency of the cache, this could also
hurt the correctness of Nix if we’re not careful enough.&lt;/p&gt;
&lt;p&gt;For example, consider the following dependency graph:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;Dependency graph for foo&quot; src=&quot;https://www.tweag.io/ed2e0194aec593229aefb7d515af8dea/foo-dependency-graph.svg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Alice wants to get &lt;code class=&quot;language-text&quot;&gt;foo&lt;/code&gt; installed.
She already built &lt;code class=&quot;language-text&quot;&gt;lib0&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;lib1&lt;/code&gt; locally.
Let’s call them &lt;code class=&quot;language-text&quot;&gt;lib0_a&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;lib1_a&lt;/code&gt;.
The binary cache contains builds of &lt;code class=&quot;language-text&quot;&gt;lib0&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;lib2&lt;/code&gt;.
Let’s call them &lt;code class=&quot;language-text&quot;&gt;lib0_b&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;lib2_b&lt;/code&gt;.
Because the build of &lt;code class=&quot;language-text&quot;&gt;lib0&lt;/code&gt; is not deterministic, &lt;code class=&quot;language-text&quot;&gt;lib0_a&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;lib0_b&lt;/code&gt; are different — and so have a different hash.
In a content-addressed word, that means they will be stored in different paths.&lt;/p&gt;
&lt;p&gt;A simple cache implementation would want to fetch &lt;code class=&quot;language-text&quot;&gt;lib2_b&lt;/code&gt; from the cache and use it to build &lt;code class=&quot;language-text&quot;&gt;foo&lt;/code&gt;.
This would also pull &lt;code class=&quot;language-text&quot;&gt;lib0_b&lt;/code&gt;, because it’s a dependency of &lt;code class=&quot;language-text&quot;&gt;lib2_b&lt;/code&gt;.
But that would mean that &lt;code class=&quot;language-text&quot;&gt;foo&lt;/code&gt; would depend on both &lt;code class=&quot;language-text&quot;&gt;lib0_a&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;lib0_b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;Buggy runtime dependency graph for foo&quot; src=&quot;https://www.tweag.io/1c4871115391af30e3309771a32df899/foo-runtime-dependency-graph.svg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;In the happy case this would just be a waste of space − the dependency is duplicated, so we use twice as much memory to store it.
But in many cases this would simply blow-up at some point — for example if &lt;code class=&quot;language-text&quot;&gt;lib0&lt;/code&gt; is a shared library, the C linker will fail because of the duplicated symbols.
Besides that, this breaks down the purity of the build as we get a different behavior depending on what’s already in the store at the start of the build.&lt;/p&gt;
&lt;h2&gt;Getting out of this&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://edolstra.github.io/pubs/phd-thesis.pdf&quot;&gt;Nix’s foundational paper&lt;/a&gt; shows a way out of this by rewriting hashes in substituted paths.
This is however quite complex to implement for a first version, so the current implementation settles down on a simpler (though not optimal) behavior where we only allow one build for each derivation.
In the example above, &lt;code class=&quot;language-text&quot;&gt;lib0&lt;/code&gt; has already been instantiated (as &lt;code class=&quot;language-text&quot;&gt;lib0_a&lt;/code&gt;), so we don’t allow pulling in &lt;code class=&quot;language-text&quot;&gt;lib0_b&lt;/code&gt; (nor &lt;code class=&quot;language-text&quot;&gt;lib1_b&lt;/code&gt;) and we rebuild both &lt;code class=&quot;language-text&quot;&gt;lib1&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;foo&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;While not optimal − we’ll end-up rebuilding &lt;code class=&quot;language-text&quot;&gt;foo&lt;/code&gt; even if it’s already in the binary cache − this solution has the advantage of preserving correctness while staying conceptually and technically simple.&lt;/p&gt;
&lt;h1&gt;What now?&lt;/h1&gt;
&lt;p&gt;Part of this &lt;a href=&quot;https://github.com/NixOS/nix/pulls?q=is%3Apr+label%3Aca-derivations+is%3Aclosed&quot;&gt;has already been implemented&lt;/a&gt; but there’s still &lt;a href=&quot;https://github.com/NixOS/nix/issues?q=is%3Aopen+is%3Aissue+label%3Aca-derivations&quot;&gt;quite a long way forward&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I hope for it to be usable (though maybe still experimental) for Nix 3.0.&lt;/p&gt;
&lt;p&gt;And in the meantime stay tuned with &lt;a href=&quot;https://discourse.nixos.org/t/tweag-nix-dev-update-4/9862&quot;&gt;our regular updates on discourse&lt;/a&gt;.
Or wait for the next blog post that will explain another change that will be necessary — one that is less fundamental, but more user-facing.&lt;/p&gt;</description>
	<pubDate>Wed, 18 Nov 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Cachix: Write access control for binary caches</title>
	<guid isPermaLink="true">https://blog.cachix.org/posts/2020-11-09-write-access-control-for-binary-caches/</guid>
	<link>https://blog.cachix.org/posts/2020-11-09-write-access-control-for-binary-caches/</link>
	<description>As Cachix is growing, I have noticed a few issues along the way: Signing keys are still the best way to upload content and not delegate trust to Cachix, but users have also found that they can be difficult to manage, particularly if the secret key needs to be rotated.
At this point, the best option is to clear out the cache completely, and re-sign everything with a newly generated key.</description>
	<pubDate>Tue, 10 Nov 2020 11:00:00 +0000</pubDate>
	<author>support@cachix.org (Domen Kožar)</author>
</item>
<item>
	<title>Sander van der Burg: Building multi-process Docker images with the Nix process management framework</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-1397115249631682228.post-5601957671436536281</guid>
	<link>http://sandervanderburg.blogspot.com/2020/10/building-multi-process-docker-images.html</link>
	<description>Some time ago, I have described &lt;a href=&quot;https://sandervanderburg.blogspot.com/2019/11/a-nix-based-functional-organization-for.html&quot;&gt;my experimental Nix-based process management framework&lt;/a&gt; that makes it possible to automatically &lt;strong&gt;deploy&lt;/strong&gt; running &lt;strong&gt;processes&lt;/strong&gt; (sometimes also ambiguously called services) from declarative specifications written in the &lt;a href=&quot;https://sandervanderburg.blogspot.com/2012/11/an-alternative-explaination-of-nix.html&quot;&gt;Nix expression language&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;The framework is built around two concepts. As its name implies, the &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/01/nix-package-manager.html&quot;&gt;&lt;strong&gt;Nix package manager&lt;/strong&gt;&lt;/a&gt; is used to deploy all required packages and static artifacts, and a &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/02/a-declarative-process-manager-agnostic.html&quot;&gt;&lt;strong&gt;process manager&lt;/strong&gt; of choice&lt;/a&gt; (e.g. sysvinit, systemd, supervisord and others) is used to manage the life-cycles of the processes.&lt;br /&gt;&lt;br /&gt;Moreover, it is built around &lt;strong&gt;flexible concepts&lt;/strong&gt; allowing integration with solutions that are not qualified as process managers (but can still be used as such), such as &lt;a href=&quot;https://docker.com&quot;&gt;Docker&lt;/a&gt; -- &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/08/experimenting-with-nix-and-service.html&quot;&gt;each process instance can be deployed as a Docker container&lt;/a&gt; with a shared Nix store using the host system's network.&lt;br /&gt;&lt;br /&gt;As explained in &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/07/on-using-nix-and-docker-as-deployment.html&quot;&gt;an earlier blog post&lt;/a&gt;, Docker has become such a popular solution that it has become a standard for deploying (micro)services (often as a utility in the &lt;a href=&quot;https://kubernetes.io&quot;&gt;Kubernetes&lt;/a&gt; solution stack).&lt;br /&gt;&lt;br /&gt;When deploying a system that consists of multiple services with Docker, a typical strategy (and recommended practice) is to use multiple containers that have &lt;a href=&quot;https://runnable.com/docker/rails/run-multiple-processes-in-a-container&quot;&gt;only one root application process&lt;/a&gt;. Advantages of this approach is that Docker can control the life-cycles of the applications, and that each process is (somewhat) isolated/protected from other processes and the host system.&lt;br /&gt;&lt;br /&gt;By default, containers are isolated, but if they need to interact with other processes, then they can use all kinds of &lt;strong&gt;integration&lt;/strong&gt; facilities -- for example, they can share namespaces, or use shared volumes.&lt;br /&gt;&lt;br /&gt;In some situations, it may also be desirable to &lt;strong&gt;deviate&lt;/strong&gt; from the one root process per container practice -- for some systems, processes may need to interact quite intensively (e.g. with IPC mechanisms, shared files or shared memory, or a combination these) in which the container boundaries introduce more inconveniences than benefits.&lt;br /&gt;&lt;br /&gt;Moreover, when running multiple processes in a single container, common dependencies can also typically be more efficiently shared leading to lower disk and RAM consumption.&lt;br /&gt;&lt;br /&gt;As explained in my previous blog post (that explores various Docker concepts), sharing dependencies between containers only works if containers are constructed from images that share the same layers with the same shared libraries. In practice, this form of sharing is not always as efficient as we want it to be.&lt;br /&gt;&lt;br /&gt;Configuring a Docker image to run multiple application processes is somewhat cumbersome -- &lt;a href=&quot;https://docs.docker.com/config/containers/multi-service_container/&quot;&gt;the official Docker documentation&lt;/a&gt; describes two solutions: one that relies on a &lt;strong&gt;wrapper&lt;/strong&gt; script that starts multiple processes in the background and a loop that waits for the &quot;main process&quot; to terminate, and the other is to use a &lt;strong&gt;process manager&lt;/strong&gt;, such as supervisord.&lt;br /&gt;&lt;br /&gt;I realised that I could solve this problem much more conveniently by combining the &lt;i&gt;dockerTools.buildImage {}&lt;/i&gt; function in Nixpkgs (that builds Docker images with the Nix package manager) with the Nix process management abstractions.&lt;br /&gt;&lt;br /&gt;I have created my own abstraction function: &lt;i&gt;createMultiProcessImage&lt;/i&gt; that builds multi-process Docker images, managed by any supported process manager that works in a Docker container.&lt;br /&gt;&lt;br /&gt;In this blog post, I will describe how this function is implemented and how it can be used.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Creating images for single root process containers&lt;/h2&gt;&lt;br /&gt;As shown in earlier blog posts, creating a Docker image with Nix for a single root application process is very straight forward.&lt;br /&gt;&lt;br /&gt;For example, we can build an image that launches a trivial web application service with an embedded HTTP server (as shown in many of my previous blog posts), as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{dockerTools, webapp}:  &lt;br /&gt;&lt;br /&gt;dockerTools.buildImage {&lt;br /&gt;  name = &quot;webapp&quot;;&lt;br /&gt;  tag = &quot;test&quot;;&lt;br /&gt;&lt;br /&gt;  runAsRoot = ''&lt;br /&gt;    ${dockerTools.shadowSetup}&lt;br /&gt;    groupadd webapp&lt;br /&gt;    useradd webapp -g webapp -d /dev/null&lt;br /&gt;  '';&lt;br /&gt;&lt;br /&gt;  config = {&lt;br /&gt;    Env = [ &quot;PORT=5000&quot; ];&lt;br /&gt;    Cmd = [ &quot;${webapp}/bin/webapp&quot; ];&lt;br /&gt;    Expose = {&lt;br /&gt;      &quot;5000/tcp&quot; = {};&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expression (&lt;i&gt;default.nix&lt;/i&gt;) invokes the &lt;i&gt;dockerTools.buildImage&lt;/i&gt; function to automatically construct an image with the following properties:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;The image has the following name: &lt;i&gt;webapp&lt;/i&gt; and the following version tag: &lt;i&gt;test&lt;/i&gt;.&lt;/li&gt;  &lt;li&gt;The web application service requires some &lt;strong&gt;state&lt;/strong&gt; to be initialized before it can be used. To configure state, we can run instructions in a QEMU virual machine with root privileges (&lt;i&gt;runAsRoot&lt;/i&gt;).&lt;br /&gt;    &lt;br /&gt;    In the above deployment Nix expression, we create an unprivileged user and group named: &lt;i&gt;webapp&lt;/i&gt;. For production deployments, it is typically recommended to drop root privileges, for security reasons.&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;Env&lt;/i&gt; directive is used to configure environment variables. The &lt;i&gt;PORT&lt;/i&gt; environment variable is used to configure the TCP port where the service should bind to.&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;Cmd&lt;/i&gt; directive starts the &lt;i&gt;webapp&lt;/i&gt; process in foreground mode. The life-cycle of the container is bound to this application process.&lt;/li&gt;  &lt;li&gt;&lt;i&gt;Expose&lt;/i&gt; exposes TCP port 5000 to the public so that the service can respond to requests made by clients.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;We can build the Docker image as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nix-build&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;load it into Docker with the following command:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker load -i result&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;and launch a container instance using the image as a template:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker run -it -p 5000:5000 webapp:test&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;If the deployment of the container succeeded, we should get a response from the &lt;i&gt;webapp&lt;/i&gt; process, by running:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ curl http://localhost:5000&lt;br /&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br /&gt;&amp;lt;html&amp;gt;&lt;br /&gt;  &amp;lt;head&amp;gt;&lt;br /&gt;    &amp;lt;title&amp;gt;Simple test webapp&amp;lt;/title&amp;gt;&lt;br /&gt;  &amp;lt;/head&amp;gt;&lt;br /&gt;  &amp;lt;body&amp;gt;&lt;br /&gt;    Simple test webapp listening on port: 5000&lt;br /&gt;  &amp;lt;/body&amp;gt;&lt;br /&gt;&amp;lt;/html&amp;gt;&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h2&gt;Creating multi-process images&lt;/h2&gt;&lt;br /&gt;As shown in previous blog posts, the &lt;i&gt;webapp&lt;/i&gt; process is part of a bigger system, namely: a web application system with an Nginx reverse proxy forwarding requests to multiple &lt;i&gt;webapp&lt;/i&gt; instances:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{ pkgs ? import &amp;lt;nixpkgs&amp;gt; { inherit system; }&lt;br /&gt;, system ? builtins.currentSystem&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  sharedConstructors = import ../services-agnostic/constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir cacheDir tmpDir forceDisableUserChange processManager;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir forceDisableUserChange processManager;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp = rec {&lt;br /&gt;    port = 5000;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  nginx = rec {&lt;br /&gt;    port = 8080;&lt;br /&gt;&lt;br /&gt;    pkg = sharedConstructors.nginxReverseProxyHostBased {&lt;br /&gt;      webapps = [ webapp ];&lt;br /&gt;      inherit port;&lt;br /&gt;    } {};&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The Nix expression above shows a simple &lt;strong&gt;processes model&lt;/strong&gt; variant of that system, that consists of only two process instances:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;The &lt;i&gt;webapp&lt;/i&gt; process is (as shown earlier) an application that returns a static HTML page.&lt;/li&gt;  &lt;li&gt;&lt;i&gt;nginx&lt;/i&gt; is configured as a reverse proxy to forward incoming connections to multiple &lt;i&gt;webapp&lt;/i&gt; instances using the virtual host header property (&lt;i&gt;dnsName&lt;/i&gt;).&lt;br /&gt;    &lt;br /&gt;    If somebody connects to the &lt;i&gt;nginx&lt;/i&gt; server with the following host name: &lt;i&gt;webapp.local&lt;/i&gt; then the request is forwarded to the &lt;i&gt;webapp&lt;/i&gt; service.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;h3&gt;Configuration steps&lt;/h3&gt;&lt;br /&gt;To allow all processes in the process model shown to be deployed to a single container, we need to execute the following steps in the construction of an image:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;Instead of deploying a single package, such as &lt;i&gt;webapp&lt;/i&gt;, we need to refer to a collection of packages and/or configuration files that can be managed with a process manager, such as sysvinit, systemd or supervisord.&lt;br /&gt;    &lt;br /&gt;    The Nix process management framework provides all kinds of Nix function abstractions to accomplish this.&lt;br /&gt;    &lt;br /&gt;    For example, the following function invocation builds a configuration profile for the sysvinit process manager, containing a collection of &lt;i&gt;sysvinit&lt;/i&gt; scripts (also known as &lt;a href=&quot;https://wiki.debian.org/LSBInitScripts&quot;&gt;LSB Init&lt;/a&gt; compliant scripts):&lt;br /&gt;    &lt;br /&gt;    &lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;profile = import ../create-managed-process/sysvinit/build-sysvinit-env.nix {&lt;br /&gt;  exprFile = ./processes.nix;&lt;br /&gt;  stateDir = &quot;/var&quot;;&lt;br /&gt;};&lt;br /&gt;    &lt;/pre&gt;    &lt;br /&gt;  &lt;/li&gt;  &lt;li&gt;Similar to single root process containers, we may also need to initialize state. For example, we need to create common FHS state directories (e.g. &lt;i&gt;/tmp&lt;/i&gt;, &lt;i&gt;/var&lt;/i&gt; etc.) in which services can store their relevant state files (e.g. log files, temp files).&lt;br /&gt;    &lt;br /&gt;    This can be done by running the following command:&lt;br /&gt;    &lt;br /&gt;    &lt;pre&gt;&lt;br /&gt;nixproc-init-state --state-dir /var&lt;br /&gt;    &lt;/pre&gt;  &lt;/li&gt;  &lt;li&gt;Another property that multiple process containers have in common is that they may also require the presence of unprivileged users and groups, for security reasons.&lt;br /&gt;    &lt;br /&gt;    With the following commands, we can automatically generate all required users and groups specified in a deployment profile:&lt;br /&gt;    &lt;br /&gt;    &lt;pre&gt;&lt;br /&gt;${dysnomia}/bin/dysnomia-addgroups ${profile}&lt;br /&gt;${dysnomia}/bin/dysnomia-addusers ${profile}&lt;br /&gt;    &lt;/pre&gt;  &lt;/li&gt;  &lt;li&gt;Instead of starting a (single root) application process, we need to start a process manager that manages the processes that we want to deploy. As already explained, the framework allows you to pick multiple options.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;h3&gt;Starting a process manager as a root process&lt;/h3&gt;&lt;br /&gt;From all process managers that the framework currently supports, the most straight forward option to use in a Docker container is: supervisord.&lt;br /&gt;&lt;br /&gt;To use it, we can create a symlink to the supervisord configuration in the deployment profile:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;ln -s ${profile} /etc/supervisor&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;and then start supervisord as a root process with the following command directive:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;Cmd = [&lt;br /&gt;  &quot;${pkgs.pythonPackages.supervisor}/bin/supervisord&quot;&lt;br /&gt;  &quot;--nodaemon&quot;&lt;br /&gt;  &quot;--configuration&quot; &quot;/etc/supervisor/supervisord.conf&quot;&lt;br /&gt;  &quot;--logfile&quot; &quot;/var/log/supervisord.log&quot;&lt;br /&gt;  &quot;--pidfile&quot; &quot;/var/run/supervisord.pid&quot;&lt;br /&gt;];&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;(As a sidenote: creating a symlink is not strictly required, but makes it possible to control running services with the &lt;i&gt;supervisorctl&lt;/i&gt; command-line tool).&lt;br /&gt;&lt;br /&gt;Supervisord is not the only option. We can also use sysvinit scripts, but doing so is a bit tricky. As explained earlier, the life-cycle of container is bound to a running root process (in foreground mode).&lt;br /&gt;&lt;br /&gt;sysvinit scripts do not run in the foreground, but start processes that daemonize and terminate immediately, leaving daemon processes behind that remain running in the background.&lt;br /&gt;&lt;br /&gt;As described in an earlier blog post about translating high-level process management concepts, it is also possible to run &quot;daemons in the foreground&quot; by creating a proxy script. We can also make a similar foreground proxy for a collection of daemons:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;#!/bin/bash -e&lt;br /&gt;&lt;br /&gt;_term()&lt;br /&gt;{&lt;br /&gt;    nixproc-sysvinit-runactivity -r stop ${profile}&lt;br /&gt;    kill &quot;$pid&quot;&lt;br /&gt;    exit 0&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;nixproc-sysvinit-runactivity start ${profile}&lt;br /&gt;&lt;br /&gt;# Keep process running, but allow it to respond to the TERM and INT&lt;br /&gt;# signals so that all scripts are stopped properly&lt;br /&gt;&lt;br /&gt;trap _term TERM&lt;br /&gt;trap _term INT&lt;br /&gt;&lt;br /&gt;tail -f /dev/null &amp;amp; pid=$!&lt;br /&gt;wait &quot;$pid&quot;&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above proxy script does the following:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;It first starts all sysvinit scripts by invoking the &lt;i&gt;nixproc-sysvinit-runactivity start&lt;/i&gt; command.&lt;/li&gt;  &lt;li&gt;Then it registers a signal handler for the &lt;i&gt;TERM&lt;/i&gt; and &lt;i&gt;INT&lt;/i&gt; signals. The corresponding callback triggers a shutdown procedure.&lt;/li&gt;  &lt;li&gt;We invoke a dummy command that keeps running in the foreground without consuming too many system resources (&lt;i&gt;tail -f /dev/null&lt;/i&gt;) and we wait for it to terminate.&lt;/li&gt;  &lt;li&gt;The signal handler properly deactivates all processes in reverse order (with the &lt;i&gt;nixproc-sysvinit-runactivity -r stop&lt;/i&gt; command), and finally terminates the dummy command causing the script (and the container) to stop.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;In addition supervisord and sysvinit, we can also use &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/06/using-disnix-as-simple-and-minimalistic.html&quot;&gt;Disnix as a process manager&lt;/a&gt; by using a similar strategy with a foreground proxy.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Other configuration properties&lt;/h3&gt;&lt;br /&gt;The above configuration properties suffice to get a multi-process container running. However, to make working with such containers more practical from a user perspective, we may also want to:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;Add basic shell utilities to the image, so that you can control the processes, investigate log files (in case of errors), and do other maintenance tasks.&lt;/li&gt;  &lt;li&gt;Add a &lt;i&gt;.bashrc&lt;/i&gt; configuration file to make file coloring working for the &lt;i&gt;ls&lt;/i&gt; command, and to provide a decent prompt in a shell session.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;h2&gt;Usage&lt;/h2&gt;&lt;br /&gt;The configuration steps described in the previous section are wrapped into a function named: &lt;i&gt;createMultiProcessImage&lt;/i&gt;, which itself is a thin wrapper around the &lt;i&gt;dockerTools.buildImage&lt;/i&gt; function in Nixpkgs -- it accepts the same parameters with a number of additional parameters that are specific to multi-process configurations.&lt;br /&gt;&lt;br /&gt;The following function invocation builds a multi-process container deploying our example system, using supervisord as a process manager:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;let&lt;br /&gt;  pkgs = import &amp;lt;nixpkgs&amp;gt; {};&lt;br /&gt;&lt;br /&gt;  createMultiProcessImage = import ../../nixproc/create-multi-process-image/create-multi-process-image.nix {&lt;br /&gt;    inherit pkgs system;&lt;br /&gt;    inherit (pkgs) dockerTools stdenv;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;createMultiProcessImage {&lt;br /&gt;  name = &quot;multiprocess&quot;;&lt;br /&gt;  tag = &quot;test&quot;;&lt;br /&gt;  exprFile = ./processes.nix;&lt;br /&gt;  stateDir = &quot;/var&quot;;&lt;br /&gt;  processManager = &quot;supervisord&quot;;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;After building the image, and deploying a container, with the following commands:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nix-build&lt;br /&gt;$ docker load -i result&lt;br /&gt;$ docker run -it --network host multiprocessimage:test&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;we should be able to connect to the &lt;i&gt;webapp&lt;/i&gt; instance via the &lt;i&gt;nginx&lt;/i&gt; reverse proxy:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ curl -H 'Host: webapp.local' http://localhost:8080&lt;br /&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br /&gt;&amp;lt;html&amp;gt;&lt;br /&gt;  &amp;lt;head&amp;gt;&lt;br /&gt;    &amp;lt;title&amp;gt;Simple test webapp&amp;lt;/title&amp;gt;&lt;br /&gt;  &amp;lt;/head&amp;gt;&lt;br /&gt;  &amp;lt;body&amp;gt;&lt;br /&gt;    Simple test webapp listening on port: 5000&lt;br /&gt;  &amp;lt;/body&amp;gt;&lt;br /&gt;&amp;lt;/html&amp;gt;&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;As explained earlier, the constructed image also provides extra command-line utilities to do maintenance tasks, and control the life-cycle of the individual processes.&lt;br /&gt;&lt;br /&gt;For example, we can &quot;connect&quot; to the running container, and check which processes are running:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker exec -it mycontainer /bin/bash&lt;br /&gt;# supervisorctl&lt;br /&gt;nginx                            RUNNING   pid 11, uptime 0:00:38&lt;br /&gt;webapp                           RUNNING   pid 10, uptime 0:00:38&lt;br /&gt;supervisor&amp;gt;&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;If we change the &lt;i&gt;processManager&lt;/i&gt; parameter to &lt;i&gt;sysvinit&lt;/i&gt;, we can deploy a multi-process image in which the foreground proxy script is used as a root process (that starts and stops sysvinit scripts).&lt;br /&gt;&lt;br /&gt;We can control the life-cycle of each individual process by directly invoking the sysvinit scripts in the container:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker exec -it mycontainer /bin/bash&lt;br /&gt;$ /etc/rc.d/init.d/webapp status&lt;br /&gt;webapp is running with Process ID(s) 33.&lt;br /&gt;&lt;br /&gt;$ /etc/rc.d/init.d/nginx status&lt;br /&gt;nginx is running with Process ID(s) 51.&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Although having extra command-line utilities to do administration tasks is useful, a disadvantage is that they considerably increase the size of the image.&lt;br /&gt;&lt;br /&gt;To save storage costs, it is also possible to disable &lt;i&gt;interactive&lt;/i&gt; mode to exclude these packages:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;let&lt;br /&gt;  pkgs = import &amp;lt;nixpkgs&amp;gt; {};&lt;br /&gt;&lt;br /&gt;  createMultiProcessImage = import ../../nixproc/create-multi-process-image/create-multi-process-image.nix {&lt;br /&gt;    inherit pkgs system;&lt;br /&gt;    inherit (pkgs) dockerTools stdenv;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;createMultiProcessImage {&lt;br /&gt;  name = &quot;multiprocess&quot;;&lt;br /&gt;  tag = &quot;test&quot;;&lt;br /&gt;  exprFile = ./processes.nix;&lt;br /&gt;  stateDir = &quot;/var&quot;;&lt;br /&gt;  processManager = &quot;supervisord&quot;;&lt;br /&gt;  interactive = false; # Do not install any additional shell utilities&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h2&gt;Discussion&lt;/h2&gt;&lt;br /&gt;In this blog post, I have described a new utility function in the Nix process management framework: &lt;i&gt;createMultiProcessImage&lt;/i&gt; -- a thin wrapper around the &lt;i&gt;dockerTools.buildImage&lt;/i&gt; function that can be used to convienently build multi-process Docker images, using any Docker-capable process manager that the Nix process management framework supports.&lt;br /&gt;&lt;br /&gt;Besides the fact that we can convienently construct multi-process images, this function also has the advantage (similar to the &lt;i&gt;dockerTools.buildImage&lt;/i&gt; function) that Nix is only required for the construction of the image. To deploy containers from a multi-process image, Nix is not a requirement.&lt;br /&gt;&lt;br /&gt;There is also a drawback: similar to &quot;ordinary&quot; multi-process container deployments, when it is desired to upgrade a process, the entire container needs to be redeployed, also requiring a user to terminate all other running processes.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Availability&lt;/h2&gt;&lt;br /&gt;The &lt;i&gt;createMultiProcessImage&lt;/i&gt; function is part of the current development version of the &lt;a href=&quot;https://github.com/svanderburg/nix-processmgmt&quot;&gt;Nix process management framework&lt;/a&gt; that can be obtained from my GitHub page.&lt;br /&gt;&lt;br /&gt;</description>
	<pubDate>Sat, 31 Oct 2020 15:05:00 +0000</pubDate>
	<author>noreply@blogger.com (Sander van der Burg)</author>
</item>
<item>
	<title>Tweag I/O: Nickel: better configuration for less</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-10-22-nickel-open-sourcing/</guid>
	<link>https://tweag.io/blog/2020-10-22-nickel-open-sourcing/</link>
	<description>&lt;p&gt;We are making the &lt;a href=&quot;https://www.github.com/tweag/nickel&quot;&gt;Nickel&lt;/a&gt; repository public. Nickel is an experimental configuration
language developed at Tweag. While this is not the time for the first
release yet, it is an occasion to talk about this project. The goal of this
post is to give a high-level overview of the project. If your curiosity is tickled
but you are left wanting to learn more, fear not, as we will publish
more blog posts on specific aspects of the language in the future. But for
now, let’s have a tour!&lt;/p&gt;
&lt;p&gt;[&lt;strong&gt;Disclaimer&lt;/strong&gt;: the actual syntax of Nickel being still worked on, I’m freely
using as-of-yet non-existing syntax for illustrative purposes. The underlying
features are however already supported.]&lt;/p&gt;
&lt;h2&gt;The inception&lt;/h2&gt;
&lt;p&gt;We, at Tweag, are avid users of the &lt;a href=&quot;https://nixos.org/&quot;&gt;Nix&lt;/a&gt; package manager. As it
happens, the configuration language for Nix (also called Nix) is
a pretty good configuration language, and would be applicable to many
more things than just package management.&lt;/p&gt;
&lt;p&gt;All in all, the Nix language is a lazy JSON with functions. It is
simple yet powerful. It is used to generate Nix’s package descriptions
but would be well
suited to write any kind of configuration (&lt;a href=&quot;https://www.terraform.io/&quot;&gt;Terraform&lt;/a&gt;,
&lt;a href=&quot;https://kubernetes.io/&quot;&gt;Kubernetes&lt;/a&gt;, etc…).&lt;/p&gt;
&lt;p&gt;The rub is that the interpreter for Nix-the-language is tightly
coupled with Nix-the-package manager. So, as it stands, using the
Nix language for anything else than package management is a rather
painful exercise.&lt;/p&gt;
&lt;p&gt;Nickel is our attempt at answering the question: what would
Nix-the-language look like if it was split from the package manager?
While taking the opportunity to improve the language a little,
building on the experience of the Nix community over the years.&lt;/p&gt;
&lt;h2&gt;What’s Nickel, exactly ?&lt;/h2&gt;
&lt;p&gt;Nickel is a lightweight generic configuration language. In that it can
replace YAML as your application’s configuration language. Unlike
YAML, though, it anticipates large configurations by being
programmable. Another way to use Nickel is to generate static
configuration files — &lt;em&gt;e.g.&lt;/em&gt; in JSON, YAML — that are then fed to another system. Like
Nix, it is designed to have a simple, well-understood core: at its
heart, it is JSON with functions.&lt;/p&gt;
&lt;p&gt;But past experience with Nix also brings some insights on which aspects of the
language could be improved. Whatever the initial scope of a language is, it will
almost surely be used in a way that deviates from the original plan: you create
a configuration language to describe software packages, and next thing you know,
somebody needs to implement a &lt;a href=&quot;https://github.com/NixOS/nixpkgs/pull/11484&quot;&gt;topological sort&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Nickel strives to retain the simplicity of Nix, while extending it
according to this feedback.
Though, you can do perfectly fine without the new features and just write Nix-like code.&lt;/p&gt;
&lt;h2&gt;Yet another configuration language&lt;/h2&gt;
&lt;p&gt;At this point you’re probably wondering if this hasn’t already been done elsewhere.
It seems that more and more languages are born every day, and surely there
already exist configuration languages with a similar purpose to Nickel:
&lt;a href=&quot;https://github.com/bazelbuild/starlark&quot;&gt;Starlark&lt;/a&gt;, &lt;a href=&quot;https://jsonnet.org/&quot;&gt;Jsonnet&lt;/a&gt;, &lt;a href=&quot;https://dhall-lang.org/&quot;&gt;Dhall&lt;/a&gt; or &lt;a href=&quot;https://cuelang.org/&quot;&gt;CUE&lt;/a&gt;, to name
a few. So why Nickel?&lt;/p&gt;
&lt;h2&gt;Typing&lt;/h2&gt;
&lt;p&gt;Perhaps the most important difference with other configuration languages is
Nickel’s approach to typing.&lt;/p&gt;
&lt;p&gt;Some languages, such as &lt;a href=&quot;https://jsonnet.org/&quot;&gt;Jsonnet&lt;/a&gt; or &lt;a href=&quot;https://github.com/bazelbuild/starlark&quot;&gt;Starlark&lt;/a&gt;, are not
statically typed. Indeed, static types can be seen as superflous in a configuration
language: if your program is only run once on fixed inputs, any type error will
be reported at run-time anyway. Why bother with a static type system?&lt;/p&gt;
&lt;p&gt;On the other hand, more and more systems rely on complex configurations, such as
cloud infrastructure (&lt;a href=&quot;https://www.terraform.io/&quot;&gt;Terraform&lt;/a&gt;, &lt;a href=&quot;https://kubernetes.io/&quot;&gt;Kubernetes&lt;/a&gt; or
&lt;a href=&quot;https://github.com/NixOS/nixops&quot;&gt;NixOps&lt;/a&gt;), leading the corresponding programs to become increasingly
complex, to the point where static types are beneficial. For reusable code —
that is, library functions — static types add structure, serve as
documentation, and eliminate bugs early.&lt;/p&gt;
&lt;p&gt;Although less common, some configuration languages are statically typed,
including &lt;a href=&quot;https://dhall-lang.org/&quot;&gt;Dhall&lt;/a&gt; and &lt;a href=&quot;https://cuelang.org/&quot;&gt;CUE&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Dhall features a powerful type system that is able to type a wide range of
idioms. But it is complex, requiring some experience to become fluent in.&lt;/p&gt;
&lt;p&gt;CUE is closer to what we are striving for. It has an optional and well-behaved
type system with strong guarantees. In exchange for which, one can’t write nor
type higher-order functions in general, even if some simple functions are
possible to encode.&lt;/p&gt;
&lt;h3&gt;Gradual typing&lt;/h3&gt;
&lt;p&gt;Nickel, features a &lt;a href=&quot;https://en.wikipedia.org/wiki/Gradual_typing&quot;&gt;&lt;em&gt;gradual type system&lt;/em&gt;&lt;/a&gt;.
Gradual types are unobtrusive: they make it possible to statically
type reusable parts of your programs, but you are still free to write
configurations without any types. The
interpreter safely handles the interaction between the typed and untyped worlds.&lt;/p&gt;
&lt;p&gt;Concretely, typed library code like this:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// file: mylib.ncl
{
  numToStr : Num -&amp;gt; Str = fun n =&amp;gt; ...;
  makeURL : Str -&amp;gt; Str -&amp;gt; Num -&amp;gt; Str = fun proto host port =&amp;gt;
    &quot;${proto}://${host}:${numToStr port}/&quot;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;can coexist with untyped configuration code like this:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// file: server.ncl
let mylib = import &quot;mylib.ncl&quot; in
let host = &quot;myproject.com&quot; in
{
  host = host;
  port = 1;
  urls = [
    mylib.makeURL &quot;myproto&quot; host port,
    {protocol = &quot;proto2&quot;; server = &quot;sndserver.net&quot;; port = 4242}
  ];
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the first snippet, the body of &lt;code class=&quot;language-text&quot;&gt;numToStr&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;makeURL&lt;/code&gt; are statically
checked: wrongfully calling &lt;code class=&quot;language-text&quot;&gt;numToStr proto&lt;/code&gt; inside &lt;code class=&quot;language-text&quot;&gt;makeURL&lt;/code&gt; would raise an
error even if &lt;code class=&quot;language-text&quot;&gt;makeURL&lt;/code&gt; is never used. On the other hand, the second snippet is
not annotated, and thus not statically checked. In particular, we mix an URL
represented as a string together with one represented as a record in the same
list. The interpreter rather inserts run-time checks, or &lt;em&gt;contracts&lt;/em&gt;, such
that if &lt;code class=&quot;language-text&quot;&gt;makeURL&lt;/code&gt; is misused then the program fails with an
appropriate error.&lt;/p&gt;
&lt;p&gt;Gradual types also lets us keep the type system simple: even in
statically typed code if you want to write a component that the type
checker doesn’t know how to verify, you don’t have to type-check that
part.&lt;/p&gt;
&lt;h3&gt;Contracts&lt;/h3&gt;
&lt;p&gt;Complementary to the static type system, Nickel offers &lt;em&gt;contracts&lt;/em&gt;. Contracts
offer precise and accurate dynamic type error reporting, even in the
presence of function types. Contracts are used internally by
Nickel’s interpreter to insert guards at the boundary between typed and untyped
chunks. Contracts are available to the programmer as well, to give them the
ability to enforce type assertions at run-time in a simple way.&lt;/p&gt;
&lt;p&gt;One pleasant consequence of this design is that the exposure of the user to the
type system can be progressive:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Users writing configurations can just write Nix-like code while ignoring
(almost) everything about typing, since you can seamlessly call a typed
function from untyped code.&lt;/li&gt;
&lt;li&gt;Users writing consumers or verifiers of these configurations would use
contracts to model data schemas.&lt;/li&gt;
&lt;li&gt;Users writing libraries would instead use the static type
system.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An example of contract is given in the next section.&lt;/p&gt;
&lt;h2&gt;Schemas&lt;/h2&gt;
&lt;p&gt;While the basic computational blocks are functions, the basic data blocks in
Nickel are records (or objects in JSON). Nickel supports writing self-documenting
record schemas, such as:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;{
  host | type: Str
       | description: &quot;The host name of the server.&quot;
       | default: &quot;fallback.myserver.net&quot;
  ;

  port | type: Num
       | description: &quot;The port of the connection.&quot;
       | default: 4242
  ;

  url | type: Url
      | description: &quot;The host name of the server.&quot;
  ;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Each field can contain metadata, such as a description or default
value. These aim at being displayed in documentation, or queried by
tools.&lt;/p&gt;
&lt;p&gt;The schema can then be used as a contract. Imagine that a function has
swapped two values in its output and returns:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;{
  host = &quot;myproject.com&quot;,
  port = &quot;myproto://myproject.com:1/&quot;,
  url = 1
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Without types, this is hard to catch. Surely, an error will eventually pop up
downstream in the pipeline, but how and when? Using the schema above
will make sure that, whenever the fields are actually evaluated, the
function will be blamed in the type error.&lt;/p&gt;
&lt;p&gt;Schemas are actually part of a bigger story involving merging records
together, which, in particular, lets the schema instantiate missing
fields with their default values. It is very much inspired by the
&lt;a href=&quot;https://nixos.org/manual/nixos/stable/index.html#sec-configuration-syntax&quot;&gt;NixOs module system&lt;/a&gt; and the &lt;a href=&quot;https://cuelang.org/&quot;&gt;CUE&lt;/a&gt; language, but
it is a story for another time.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I hope that I gave you a sense of what Nickel is trying to achieve. I
only presented its most salient aspects: its gradual type system with
contracts, and built-in record schemas. But there is more to explore!
The language is not ready to be used in real world applications yet, but a good
share of the design presented here is implemented. If you are curious about it,
&lt;a href=&quot;https://www.github.com/tweag/nickel&quot;&gt;check it out&lt;/a&gt;!&lt;/p&gt;</description>
	<pubDate>Thu, 22 Oct 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Sander van der Burg: Transforming Disnix models to graphs and visualizing them</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-1397115249631682228.post-6908570302501500296</guid>
	<link>http://sandervanderburg.blogspot.com/2020/10/transforming-disnix-models-to-graphs.html</link>
	<description>In &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/09/assigning-unique-ids-to-services-in.html&quot;&gt;my previous blog post&lt;/a&gt;, I have described a new tool in the Dynamic Disnix toolset that can be used to automatically assign unique numeric IDs to services in a &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/02/disnix-toolset-for-distributed.html&quot;&gt;Disnix&lt;/a&gt; service model. Unique numeric IDs can represent all kinds of useful resources, such as TCP/UDP port numbers, user IDs (UIDs), and group IDs (GIDs).&lt;br /&gt;&lt;br /&gt;Although I am quite happy to have this tool at my disposal, implementing it was much more difficult and time consuming than I expected. Aside from the fact that the problem is not as obvious as it may sound, the main reason is that the Dynamic Disnix toolset was originally developed as a proof of concept implementation for a research paper under very high time pressure. As a result, it has accumulated quite a bit of &lt;strong&gt;technical debt&lt;/strong&gt;, that as of today, is still at a fairly high level (but much better than it was when I completed the PoC).&lt;br /&gt;&lt;br /&gt;For the ID assigner tool, I needed to make changes to the foundations of the tools, such as the model parsing libraries. As a consequence, all kinds of related aspects in the toolset started to break, such as the deployment planning algorithm implementations.&lt;br /&gt;&lt;br /&gt;Fixing some of these algorithm implementations was much more difficult than I expected -- they were not properly documented, not decomposed into functions, had little to no reuse of common concepts and as a result, were difficult to understand and change. I was forced to re-read the papers that I used as a basis for these algorithms.&lt;br /&gt;&lt;br /&gt;To prevent myself from having to go through such a painful process again, I have decided to &lt;strong&gt;revise&lt;/strong&gt; them in such a way that they are better understandable and maintainable.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Dynamically distributing services&lt;/h2&gt;&lt;br /&gt;The deployment models in the core Disnix toolset are &lt;strong&gt;static&lt;/strong&gt;. For example, the distribution of services to machines in the network is done in a &lt;strong&gt;distribution model&lt;/strong&gt; in which the user has to manually map services in the services model to target machines in the infrastructure model (and optionally to &lt;a href=&quot;https://sandervanderburg.blogspot.com/2016/06/deploying-containers-with-disnix-as.html&quot;&gt;container services&lt;/a&gt; hosted on the target machines).&lt;br /&gt;&lt;br /&gt;Each time a condition changes, e.g. the system needs to scale up or a machine crashes and the system needs to recover, a new distribution model must be configured and the system must be redeployed. For big complex systems that need to be reconfigured frequently, manually specifying new distribution models becomes very impractical.&lt;br /&gt;&lt;br /&gt;As I have already explained in older blog posts, to cope with the limitations of static deployment models (and other static configuration aspects), &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/03/self-adaptive-deployment-with-disnix.html&quot;&gt;I have developed Dynamic Disnix&lt;/a&gt;, in which various configuration aspects can be automated, including the distribution of services to machines.&lt;br /&gt;&lt;br /&gt;A strategy for dynamically distributing services to machines can be specified in a &lt;strong&gt;QoS model&lt;/strong&gt;, that typically consists of two phases:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;First, a &lt;strong&gt;candidate&lt;/strong&gt; target &lt;strong&gt;selection&lt;/strong&gt; must be made, in which for each service the appropriate candidate target machines are selected.&lt;br /&gt;    &lt;br /&gt;    Not all machines are capable of hosting a certain service for functional and non-functional reasons -- for example, a &lt;i&gt;i686-linux&lt;/i&gt; machine is not capable of running a binary compiled for a &lt;i&gt;x86_64-linux&lt;/i&gt; machine.&lt;br /&gt;    &lt;br /&gt;    A machine can also be exposed to the public internet, and as a result, may not be suitable to host a service that exposes privacy-sensitive information.&lt;/li&gt;  &lt;li&gt;After the suitable candidate target machines are known for each service, we must decide to which candidate machine each service gets &lt;strong&gt;distributed&lt;/strong&gt;.&lt;br /&gt;    &lt;br /&gt;    This can be done in many ways. The strategy that we want to use is typically based on all kinds of non-functional requirements.&lt;br /&gt;    &lt;br /&gt;    For example, we can optimize a system's reliability by minimizing the amount of network links between services, requiring a strategy in which services that depend on each other are mapped to the same machine, as much as possible.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;h2&gt;Graph-based optimization problems&lt;/h2&gt;&lt;br /&gt;In the Dynamic Disnix toolset, I have implemented various kinds of distribution algorithms/strategies for all kinds of purposes.&lt;br /&gt;&lt;br /&gt;I did not &quot;invent&quot; most of them -- for some, I got inspiration from papers in the academic literature.&lt;br /&gt;&lt;br /&gt;Two of the more advanced deployment planning algorithms are graph-based, to accomplish the following goals:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;&lt;strong&gt;Reliable deployment&lt;/strong&gt;. Network links are a potential source making a distributed system unreliable -- connections may fail, become slow, or could be interrupted frequently. By minimizing the amount of network links between services (by co-locating them on the same machine), their impact can be reduced. To not make deployments not too expensive, it should be done with a minimal amount of machines.&lt;br /&gt;    &lt;br /&gt;    As described in the paper: &quot;&lt;a href=&quot;https://gsd.uwaterloo.ca/publications/view/266&quot;&gt;Reliable Deployment of Component-based Applications into Distributed Environments&lt;/a&gt;&quot; by A. Heydarnoori and F. Mavaddat, this problem can be transformed into a graph problem: the multiway cut problem (which is &lt;a href=&quot;https://en.wikipedia.org/wiki/NP-hardness&quot;&gt;NP-hard&lt;/a&gt;).&lt;br /&gt;    &lt;br /&gt;    It can only be solved in polynomial time with an approximation algorithm that comes close to the optimal solution, &lt;a href=&quot;https://en.wikipedia.org/wiki/P_versus_NP_problem&quot;&gt;unless a proof that &lt;i&gt;P = NP&lt;/i&gt; exists&lt;/a&gt;.&lt;/li&gt;  &lt;li&gt;&lt;strong&gt;Fragile deployment&lt;/strong&gt;. Inspired by the above deployment problem, I also came up with the opposite problem (as my own &quot;invention&quot;) -- how can we make any connection between a service a true network link (not local), so that we can test a system for robustness, using a minimal amount of machines?&lt;br /&gt;    &lt;br /&gt;    This problem can be modeled as a graph coloring problem (that is a NP-hard problem as well). I used one of the approximation algorithms described in the paper: &quot;&lt;a href=&quot;https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.399.396&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;New Methods to Color the Vertices of a Graph&lt;/a&gt;&quot; by D. Brélaz to implement a solution.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;To work with these graph-based algorithms, I originally did not apply any transformations -- because of time pressure, I directly worked with objects from the Disnix models (e.g. services, target machines) and somewhat &quot;glued&quot; these together with generic data structures, such as lists and hash tables.&lt;br /&gt;&lt;br /&gt;As a result, when looking at the implementation, it is very hard to get an understanding of the process and how an implementation aspect relates to a concept described in the papers shown above.&lt;br /&gt;&lt;br /&gt;In my revised version, I have implemented a &lt;strong&gt;general purpose&lt;/strong&gt; graph library that can be used to solve all kinds of general graph related problems.&lt;br /&gt;&lt;br /&gt;Aside from using a general graph library, I have also separated the graph-based generation processes into the following steps:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;After opening the Disnix input models (such as the services, infrastructure, and distribution models) I &lt;strong&gt;transform&lt;/strong&gt; the models to a graph representing an instance of the problem domain.&lt;/li&gt;  &lt;li&gt;After the graph has been generated, I &lt;strong&gt;apply&lt;/strong&gt; the approximation &lt;strong&gt;algorithm&lt;/strong&gt; to the graph data structure.&lt;/li&gt;  &lt;li&gt;Finally, I &lt;strong&gt;transform&lt;/strong&gt; the resolved graph &lt;strong&gt;back&lt;/strong&gt; to a distribution model that should provide our desired distribution outcome.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;This new organization provides better separation of concerns, common concepts can be reused (such as graph operations), and as a result, the implementations are much closer to the approximation algorithms described in the papers.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Visualizing the generation process&lt;/h2&gt;&lt;br /&gt;Another advantage of having a reusable graph implementation is that we can easily extend it to &lt;strong&gt;visualize&lt;/strong&gt; the problem graphs.&lt;br /&gt;&lt;br /&gt;When I combine these features together with my earlier work that &lt;a href=&quot;https://sandervanderburg.blogspot.com/2019/02/generating-functional-architecture.html&quot;&gt;visualizes services models&lt;/a&gt;, and a new tool that visualizes infrastructure models, I can make the entire generation process transparent.&lt;br /&gt;&lt;br /&gt;For example, the following services model:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{system, pkgs, distribution, invDistribution}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  customPkgs = import ./pkgs { inherit pkgs system; };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  testService1 = {&lt;br /&gt;    name = &quot;testService1&quot;;&lt;br /&gt;    pkg = customPkgs.testService1;&lt;br /&gt;    type = &quot;echo&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  testService2 = {&lt;br /&gt;    name = &quot;testService2&quot;;&lt;br /&gt;    pkg = customPkgs.testService2;&lt;br /&gt;    dependsOn = {&lt;br /&gt;      inherit testService1;&lt;br /&gt;    };&lt;br /&gt;    type = &quot;echo&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  testService3 = {&lt;br /&gt;    name = &quot;testService3&quot;;&lt;br /&gt;    pkg = customPkgs.testService3;&lt;br /&gt;    dependsOn = {&lt;br /&gt;      inherit testService1 testService2;&lt;br /&gt;    };&lt;br /&gt;    type = &quot;echo&quot;;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;can be visualized as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix-visualize-services -s services.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-DZodrh7ANOo/X3zZCYfs_CI/AAAAAAAAKnE/cdLxBcW0uBklfyTZW6A339jjT4zEq7nhACLcBGAsYHQ/s0/services.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-DZodrh7ANOo/X3zZCYfs_CI/AAAAAAAAKnE/cdLxBcW0uBklfyTZW6A339jjT4zEq7nhACLcBGAsYHQ/s0/services.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;The above services model and corresponding visualization capture the following properties:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;They describe three &lt;strong&gt;services&lt;/strong&gt; (as denoted by ovals).&lt;/li&gt;  &lt;li&gt;The arrows denote &lt;strong&gt;inter-dependency relationships&lt;/strong&gt; (the &lt;i&gt;dependsOn&lt;/i&gt; attribute in the services model).&lt;br /&gt;    &lt;br /&gt;    When a service has an inter-dependency on another service means that the latter service has to be activated first, and that the dependent service needs to know how to reach the former.&lt;br /&gt;    &lt;br /&gt;    &lt;i&gt;testService2&lt;/i&gt; depends on &lt;i&gt;testService1&lt;/i&gt; and &lt;i&gt;testService3&lt;/i&gt; depends on both the other two services.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;We can also visualize the following infrastructure model:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{&lt;br /&gt;  testtarget1 = {&lt;br /&gt;    properties = {&lt;br /&gt;      hostname = &quot;testtarget1&quot;;&lt;br /&gt;    };&lt;br /&gt;    containers = {&lt;br /&gt;      mysql-database = {&lt;br /&gt;        mysqlPort = 3306;&lt;br /&gt;      };&lt;br /&gt;      echo = {};&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  testtarget2 = {&lt;br /&gt;    properties = {&lt;br /&gt;      hostname = &quot;testtarget2&quot;;&lt;br /&gt;    };&lt;br /&gt;    containers = {&lt;br /&gt;      mysql-database = {&lt;br /&gt;        mysqlPort = 3306;&lt;br /&gt;      };&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  testtarget3 = {&lt;br /&gt;    properties = {&lt;br /&gt;      hostname = &quot;testtarget3&quot;;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;with the following command:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix-visualize-infra -i infrastructure.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;resulting in the following visualization:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-75JCRa3nTjI/X3zZIezwY7I/AAAAAAAAKnI/CwvpKQKF4vo4JOJxfSmt5rQrh-uEBy1eACLcBGAsYHQ/s0/infrastructure.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-75JCRa3nTjI/X3zZIezwY7I/AAAAAAAAKnI/CwvpKQKF4vo4JOJxfSmt5rQrh-uEBy1eACLcBGAsYHQ/s0/infrastructure.png&quot; width=&quot;520&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;The above infrastructure model declares three machines. Each target machine provides a number of container services (such as a MySQL database server, and &lt;i&gt;echo&lt;/i&gt; that acts as a testing container).&lt;br /&gt;&lt;br /&gt;With the following command, we can generate a problem instance for the graph coloring problem using the above services and infrastructure models as inputs:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix-graphcol -s services.nix -i infrastructure.nix \&lt;br /&gt;  --output-graph&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;resulting in the following graph:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-K8kNG1TR0oE/X3zZO3f8SfI/AAAAAAAAKnM/vFp8Vu-DEBcoYHFikI1OgBNYmDJ8OKIFgCLcBGAsYHQ/s0/graphcol-instance.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-K8kNG1TR0oE/X3zZO3f8SfI/AAAAAAAAKnM/vFp8Vu-DEBcoYHFikI1OgBNYmDJ8OKIFgCLcBGAsYHQ/s0/graphcol-instance.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;The graph shown above captures the following properties:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;Each service translates to a node&lt;/li&gt;  &lt;li&gt;When an inter-dependency relationship exists between services, it gets translated to a (bi-directional) link representing a network connection (the rationale is that a service that has an inter-dependency on another service, interact with each other by using a network connection).&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Each target machine translates to a color, that we can represent with a numeric index -- &lt;i&gt;0&lt;/i&gt; is &lt;i&gt;testtarget1&lt;/i&gt;, &lt;i&gt;1&lt;/i&gt; is &lt;i&gt;testtarget2&lt;/i&gt; and so on.&lt;br /&gt;&lt;br /&gt;The following command generates the resolved problem instance graph in which each vertex has a color assigned:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix-graphcol -s services.nix -i infrastructure.nix \&lt;br /&gt;  --output-resolved-graph&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;resulting in the following visualization:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-rHVx-Y5i4ak/X3zaYQ4mbfI/AAAAAAAAKng/yyeewWiz9YIfp11ucd_VICRNsZhd8jCgwCLcBGAsYHQ/s0/graphcol-resolved.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-rHVx-Y5i4ak/X3zaYQ4mbfI/AAAAAAAAKng/yyeewWiz9YIfp11ucd_VICRNsZhd8jCgwCLcBGAsYHQ/s0/graphcol-resolved.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;(As a sidenote: in the above graph, colors are represented by numbers. In theory, I could also use real colors, but if I also want that the graph to remain visually appealing, I need to solve a color picking problem, which is beyond the scope of my refactoring objective).&lt;br /&gt;&lt;br /&gt;The resolved graph can be translated back into the following distribution model:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix-graphcol -s services.nix -i infrastructure.nix&lt;br /&gt;{&lt;br /&gt;  &quot;testService2&quot; = [&lt;br /&gt;    &quot;testtarget2&quot;&lt;br /&gt;  ];&lt;br /&gt;  &quot;testService1&quot; = [&lt;br /&gt;    &quot;testtarget1&quot;&lt;br /&gt;  ];&lt;br /&gt;  &quot;testService3&quot; = [&lt;br /&gt;    &quot;testtarget3&quot;&lt;br /&gt;  ];&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;As you may notice, every service is distributed to a separate machine, so that every network link between a service is a real network connection between machines.&lt;br /&gt;&lt;br /&gt;We can also visualize the problem instance of the multiway cut problem. For this, we also need a distribution model that, declares for each service, which target machine is a candidate.&lt;br /&gt;&lt;br /&gt;The following distribution model makes all three target machines in the infrastructure model a candidate for every service:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{infrastructure}:&lt;br /&gt;&lt;br /&gt;{&lt;br /&gt;  testService1 = [ infrastructure.testtarget1 infrastructure.testtarget2 infrastructure.testtarget3 ];&lt;br /&gt;  testService2 = [ infrastructure.testtarget1 infrastructure.testtarget2 infrastructure.testtarget3 ];&lt;br /&gt;  testService3 = [ infrastructure.testtarget1 infrastructure.testtarget2 infrastructure.testtarget3 ];&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;With the following command we can generate a problem instance representing a host-application graph:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix-multiwaycut -s services.nix -i infrastructure.nix \&lt;br /&gt;  -d distribution.nix --output-graph&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;providing me the following output:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-L402YdmM3E0/X315yEtOPnI/AAAAAAAAKoM/Mvt93ilHTQcy6liZx0rOihGufbNsbr3uACLcBGAsYHQ/s0/multiwaycut-instance.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-L402YdmM3E0/X315yEtOPnI/AAAAAAAAKoM/Mvt93ilHTQcy6liZx0rOihGufbNsbr3uACLcBGAsYHQ/s0/multiwaycut-instance.png&quot; width=&quot;520&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;The above problem graph has the following properties:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;Each service translates to an &lt;strong&gt;app node&lt;/strong&gt; (prefixed with &lt;i&gt;app:&lt;/i&gt;) and each candidate target machine to a &lt;strong&gt;host node&lt;/strong&gt; (prefixed with &lt;i&gt;host:&lt;/i&gt;).&lt;/li&gt;  &lt;li&gt;When a network connection between two services exists (implicitly derived from having an inter-dependency relationship), an edge is generated with a weight of &lt;i&gt;1&lt;/i&gt;.&lt;/li&gt;  &lt;li&gt;When a target machine is a candidate target for a service, then an edge is generated with a weight of &lt;i&gt;n&lt;sup&gt;2&lt;/sup&gt;&lt;/i&gt; representing a very large number.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;The objective of solving the multiway cut problem is to cut edges in the graph in such a way that each terminal (host node) is disconnected from the other terminals (host nodes), in which the total weight of the cuts is minimized.&lt;br /&gt;&lt;br /&gt;When applying the approximation algorithm in the paper to the above graph:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix-multiwaycut -s services.nix -i infrastructure.nix \&lt;br /&gt;  -d distribution.nix --output-resolved-graph&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;we get the following resolved graph:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-LiThHTYMe0c/X32E2yfLfTI/AAAAAAAAKoY/aZvzrtWlhHc0q_IM01BLAB3-BEkArfwzQCLcBGAsYHQ/s0/multiwaycut-resolved.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-LiThHTYMe0c/X32E2yfLfTI/AAAAAAAAKoY/aZvzrtWlhHc0q_IM01BLAB3-BEkArfwzQCLcBGAsYHQ/s0/multiwaycut-resolved.png&quot; width=&quot;520&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;that can be transformed back into the following distribution model:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix-multiwaycut -s services.nix -i infrastructure.nix \&lt;br /&gt;  -d distribution.nix&lt;br /&gt;{&lt;br /&gt;  &quot;testService2&quot; = [&lt;br /&gt;    &quot;testtarget1&quot;&lt;br /&gt;  ];&lt;br /&gt;  &quot;testService1&quot; = [&lt;br /&gt;    &quot;testtarget1&quot;&lt;br /&gt;  ];&lt;br /&gt;  &quot;testService3&quot; = [&lt;br /&gt;    &quot;testtarget1&quot;&lt;br /&gt;  ];&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;As you may notice by looking at the resolved graph (in which the terminals: &lt;i&gt;testtarget2&lt;/i&gt; and &lt;i&gt;testtarget3&lt;/i&gt; are disconnected) and the distribution model output, all services are distributed to the same machine: &lt;i&gt;testtarget1&lt;/i&gt; making all connections between the services local connections.&lt;br /&gt;&lt;br /&gt;In this particular case, the solution is not only close to the optimal solution, but it is the optimal solution.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;br /&gt;In this blog post, I have described how I have revised the deployment planning algorithm implementations in the Dynamic Disnix toolset. Their concerns are now much better separated, and the graph-based algorithms now use a general purpose graph library, that can also be used for generating visualizations of the intermediate steps in the generation process.&lt;br /&gt;&lt;br /&gt;This revision was not on my short-term planned features list, but I am happy that I did the work. Retrospectively, I regret that I never took the time to finish things up properly after the submission of the paper. Although Dynamic Disnix's quality is still not where I want it to be, it is quite a step forward in making the toolset more usable.&lt;br /&gt;&lt;br /&gt;Sadly, it is almost 10 years ago that I started Dynamic Disnix and still there is no offical release yet and the technical debt in Dynamic Disnix is one of the important reasons that I never did an official release. Hopefully, with this step I can do it some day. :-)&lt;br /&gt;&lt;br /&gt;The good news is that I made the paper submission deadline and that the paper got accepted for presentation. It brought me to the &lt;a href=&quot;https://www.hpi.uni-potsdam.de/giese/public/selfadapt/seams/&quot;&gt;SEAMS 2011&lt;/a&gt; conference (co-located with &lt;a href=&quot;http://2011.icse-conferences.org/&quot;&gt;ICSE 2011&lt;/a&gt;) in Honolulu, Hawaii, allowing me to take pictures such as this one:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-9K_pKO-lE2M/X34OOw5OexI/AAAAAAAAKoo/DS1vombgdCEQBokxPDJbvq4ibrs5PStxwCLcBGAsYHQ/s2048/P1040527.JPG&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-9K_pKO-lE2M/X34OOw5OexI/AAAAAAAAKoo/DS1vombgdCEQBokxPDJbvq4ibrs5PStxwCLcBGAsYHQ/s600/P1040527.JPG&quot; width=&quot;520&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;&lt;h2&gt;Availability&lt;/h2&gt;&lt;br /&gt;The graph library and new implementations of the deployment planning algorithms described in this blog post are part of the current development version of &lt;a href=&quot;https://github.com/svanderburg/dydisnix&quot;&gt;Dynamic Disnix&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;The paper: &quot;A Self-Adaptive Deployment Framework for Service-Oriented Systems&quot; describes the Dynamic Disnix framework (developed 9 years ago) and can be obtained from &lt;a href=&quot;http://sandervanderburg.nl/index.php/publications&quot;&gt;my publications&lt;/a&gt; page.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Acknowledgements&lt;/h2&gt;&lt;br /&gt;To generate the visualizations I used the &lt;a href=&quot;https://graphviz.org/&quot;&gt;Graphviz&lt;/a&gt; toolset.&lt;br /&gt;&lt;br /&gt;</description>
	<pubDate>Thu, 08 Oct 2020 21:29:00 +0000</pubDate>
	<author>noreply@blogger.com (Sander van der Burg)</author>
</item>
<item>
	<title>Cachix: Changes to Garbage Collection</title>
	<guid isPermaLink="true">https://blog.cachix.org/posts/2020-10-01-changes-to-garbage-collection/</guid>
	<link>https://blog.cachix.org/posts/2020-10-01-changes-to-garbage-collection/</link>
	<description>Based on your feedback, I have made the following two changes:
  When downloading &amp;lt;store-hash&amp;gt;.narinfo the timestamp of last access is updated, previously this would happen only with nar archives.
This change allows tools like nix-build-uncached to prevent unneeded downloads and playing nicely with Cachix garbage collection algorithm!
  Previously, the algorithm ordered paths first by last accessed timestamp and then by creation timestamp.
That worked well until you had all entries with last accessed and all newly created store paths will get deleted first.</description>
	<pubDate>Thu, 01 Oct 2020 09:00:00 +0000</pubDate>
	<author>support@cachix.org (Domen Kožar)</author>
</item>
<item>
	<title>Tweag I/O: Fully statically linked Haskell binaries with Bazel</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-09-30-bazel-static-haskell/</guid>
	<link>https://tweag.io/blog/2020-09-30-bazel-static-haskell/</link>
	<description>&lt;p&gt;Deploying and packaging Haskell applications can be challenging at times, and
runtime library dependencies are one reason for this. Statically linked
binaries have no such dependencies and are therefore easier to deploy. They
can also be quicker to start, since no dynamic loading is needed. In exchange,
all used symbols must be bundled into the application, which may lead to larger
artifacts.&lt;/p&gt;
&lt;p&gt;Thanks to the contribution of Will Jones of &lt;a href=&quot;https://www.habito.com/&quot;&gt;Habito&lt;/a&gt;&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a class=&quot;footnote-ref&quot; href=&quot;https://www.tweag.io/rss-nix.xml#fn-1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;,
&lt;a href=&quot;https://github.com/tweag/rules_haskell&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;rules_haskell&lt;/code&gt;&lt;/a&gt;, the Haskell &lt;a href=&quot;https://bazel.build&quot;&gt;Bazel&lt;/a&gt; extension, has
&lt;a href=&quot;https://github.com/tweag/rules_haskell/pull/1390&quot;&gt;gained support&lt;/a&gt; for fully static linking of Haskell
binaries.&lt;/p&gt;
&lt;p&gt;Habito uses Bazel to develop, build, test and deploy Haskell code in a minimal
Docker container. By building fully-statically-linked binaries, Docker
packaging (using &lt;a href=&quot;https://github.com/bazelbuild/rules_docker&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;rules_docker&lt;/code&gt;&lt;/a&gt;) becomes straightforward and
easy to integrate into existing build workflows. A static binary can also be
&lt;code class=&quot;language-text&quot;&gt;strip&lt;/code&gt;ped once it is built to reduce the size of production artifacts. With
static binaries, what you see (just the binary) is what you get, and this is
powerful.&lt;/p&gt;
&lt;p&gt;In the following, we will discuss the technical challenges of statically
linking Haskell binaries and how these challenges are addressed in
&lt;code class=&quot;language-text&quot;&gt;rules_haskell&lt;/code&gt;. Spoiler alert: Nix is an important part of the solution.
Finally, we will show you how you can create your own fully statically linked
Haskell binaries with Bazel and Nix.&lt;/p&gt;
&lt;h2&gt;Technical challenges&lt;/h2&gt;
&lt;p&gt;Creating fully statically linked Haskell binaries is not without challenges.
The main difficulties for doing so are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Not all library dependencies are suited for statically linked binaries.&lt;/li&gt;
&lt;li&gt;Compiling template Haskell requires dynamic libraries on Linux by default.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Library dependencies&lt;/h3&gt;
&lt;p&gt;Like most binaries on Linux, the Haskell compiler GHC is typically configured to
link against the &lt;a href=&quot;https://www.gnu.org/software/libc/&quot;&gt;GNU C library &lt;code class=&quot;language-text&quot;&gt;glibc&lt;/code&gt;&lt;/a&gt;. However, &lt;code class=&quot;language-text&quot;&gt;glibc&lt;/code&gt; is not
designed to support fully static linking and explicitly &lt;a href=&quot;https://sourceware.org/glibc/wiki/FAQ#Even_statically_linked_programs_need_some_shared_libraries_which_is_not_acceptable_for_me.__What_can_I_do.3F&quot;&gt;depends on dynamic
linking&lt;/a&gt; in some use cases. The alternative C library
&lt;a href=&quot;https://musl.libc.org/about.html&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;musl&lt;/code&gt;&lt;/a&gt; is designed to support fully static linking.&lt;/p&gt;
&lt;p&gt;Relatedly, there may be licensing reasons to not link some libraries
statically. Common instances in the Haskell ecosystem are again &lt;code class=&quot;language-text&quot;&gt;glibc&lt;/code&gt; which
is licensed under GPL, and the core Haskell dependency &lt;code class=&quot;language-text&quot;&gt;libgmp&lt;/code&gt; which is
licensed under LGPL. For the latter GHC can be configured to use the core
package &lt;code class=&quot;language-text&quot;&gt;integer-simple&lt;/code&gt; instead of &lt;code class=&quot;language-text&quot;&gt;integer-gmp&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Fortunately, the Nix community has made &lt;a href=&quot;https://github.com/NixOS/nixpkgs/issues/43795&quot;&gt;great
progress&lt;/a&gt; towards fully statically linked Haskell
binaries and we can build on much of this work in &lt;code class=&quot;language-text&quot;&gt;rules_haskell&lt;/code&gt;. The
&lt;a href=&quot;https://github.com/tweag/rules_nixpkgs&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;rules_nixpkgs&lt;/code&gt;&lt;/a&gt; extension makes it possible to import Nix derivations
into a Bazel project, and &lt;code class=&quot;language-text&quot;&gt;rules_haskell&lt;/code&gt; has first class support for
Nix-provided GHC toolchains using &lt;code class=&quot;language-text&quot;&gt;rules_nixpkgs&lt;/code&gt; under the hood. In
particular, it can import a GHC toolchain based on &lt;code class=&quot;language-text&quot;&gt;musl&lt;/code&gt; from
&lt;a href=&quot;https://github.com/nh2/static-haskell-nix&quot;&gt;static-haskell-nix&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Template Haskell&lt;/h3&gt;
&lt;p&gt;By default GHC is configured to require dynamic libraries when compiling
template Haskell. GHC’s runtime system (RTS) can be built in various
combinations of so called &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/compiler-ways&quot;&gt;ways&lt;/a&gt;. The relevant way in this context is
called &lt;em&gt;dynamic&lt;/em&gt;. On Linux, GHC itself is built with a dynamic RTS. However,
statically linked code is targeting a non-dynamic RTS. This may sound familiar
if you ever tried to compile code using template Haskell in profiling mode. As
the &lt;a href=&quot;https://downloads.haskell.org/ghc/8.10.1/docs/html/users_guide/glasgow_exts.html#using-template-haskell-with-profiling&quot;&gt;GHC user guide&lt;/a&gt; points out, when evaluating template Haskell
splices, GHC will execute compiled expressions in its built-in bytecode
interpreter and this code has to be compatible with the RTS of GHC itself. In
short, a GHC configured with a dynamic RTS will not be able to load static
Haskell libraries to evaluate template Haskell splices.&lt;/p&gt;
&lt;p&gt;One way to solve this issue is to compile all Haskell libraries twice, once
with dynamic linking and once with static linking. C library dependencies will
similarly need to be available in both static and dynamic forms. This is the
approach taken by &lt;code class=&quot;language-text&quot;&gt;static-haskell-nix&lt;/code&gt;. However, in the context of Bazel we
found it preferable to only compile Haskell libraries once in static form and
also only have to provide C libraries in static form. To achieve this we need
to build GHC with a static RTS and to make sure that Haskell code is
compiled as position independent code so that it can be loaded into a running
GHC for template Haskell splices. Thanks to Nix, it is easy to override the GHC
derivation to include the necessary configuration.&lt;/p&gt;
&lt;h2&gt;Make your project fully statically linked&lt;/h2&gt;
&lt;p&gt;How can you benefit from this? In this section we will show how you can setup a
Bazel Haskell project for fully static linking with Nix. For further details
please refer to the corresponding documentation on
&lt;a href=&quot;https://rules-haskell.readthedocs.io/en/latest/haskell-use-cases.html#building-fully-statically-linked-binaries&quot;&gt;haskell.build&lt;/a&gt;. A fully working example repository is
available &lt;a href=&quot;https://github.com/lunaris/minirepo&quot;&gt;here&lt;/a&gt;. For a primer on setting up a Bazel Haskell project
take a look at &lt;a href=&quot;https://www.tweag.io/blog/2020-05-06-convert-haskell-project-to-bazel/&quot;&gt;this tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;First, you need to configure a Nixpkgs repository that defines a GHC toolchain
for fully static linking based on musl. We start by pulling in a base Nixpkgs
revision and the &lt;code class=&quot;language-text&quot;&gt;static-haskell-nix&lt;/code&gt; project. Create a &lt;code class=&quot;language-text&quot;&gt;default.nix&lt;/code&gt;,
with the following.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt;
  baseNixpkgs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;builtins&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fetchTarball&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;nixos-nixpkgs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    url &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;https://github.com/NixOS/nixpkgs/archive/dca182df882db483cea5bb0115fea82304157ba1.tar.gz&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    sha256 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;0193bpsg1ssr93ihndyv7shz6ivsm8cvaxxl72mc7vfb8d1bwx55&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  staticHaskellNixpkgs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;builtins&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fetchTarball&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;https://github.com/nh2/static-haskell-nix/archive/dbce18f4808d27f6a51ce31585078b49c86bd2b5.tar.gz&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then we import a Haskell package set based on &lt;code class=&quot;language-text&quot;&gt;musl&lt;/code&gt; from &lt;code class=&quot;language-text&quot;&gt;static-haskell-nix&lt;/code&gt;.
The package set provides GHC and various Haskell packages. However, we will
only use the GHC compiler and use Bazel to build other Haskell packages.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt;
  staticHaskellPkgs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;staticHaskellNixpkgs &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;/survey/default.nix&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;approachPkgs&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next we define a Nixpkgs &lt;a href=&quot;https://nixos.org/nixpkgs/manual/#chap-overlays&quot;&gt;overlay&lt;/a&gt; that introduces a GHC based
on &lt;code class=&quot;language-text&quot;&gt;musl&lt;/code&gt; that is configured to use a static runtime system and core packages
built with position independent code so that they can be loaded for template
Haskell.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt;
  overlay &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; super&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    staticHaskell &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; staticHaskellPkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;extend &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;selfSH&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; superSH&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      ghc &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;superSH&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;ghc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;override &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        enableRelocatedStaticLibs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        enableShared &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;overrideAttrs &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;oldAttrs&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        preConfigure &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;''
          &lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token antiquotation variable&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;oldAttrs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;preConfigure &lt;span class=&quot;token keyword&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
          echo &quot;GhcLibHcOpts += -fPIC -fexternal-dynamic-refs&quot; &amp;gt;&amp;gt; mk/build.mk
          echo &quot;GhcRtsHcOpts += -fPIC -fexternal-dynamic-refs&quot; &amp;gt;&amp;gt; mk/build.mk
        ''&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, we extend the base Nixpkgs revision with the overlay. This makes the
newly configured GHC available under the Nix attribute path
&lt;code class=&quot;language-text&quot;&gt;staticHaskell.ghc&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;  args&lt;span class=&quot;token operator&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; overlays &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;import&lt;/span&gt; baseNixpkgs &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;args &lt;span class=&quot;token operator&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      overlays &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;overlay&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt; overlays&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This concludes the Nix part of the setup and we can move on to the Bazel part.&lt;/p&gt;
&lt;p&gt;You can import this Nixpkgs repository into Bazel by adding the following lines
to your &lt;code class=&quot;language-text&quot;&gt;WORKSPACE&lt;/code&gt; file.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;load&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;@io_tweag_rules_nixpkgs//nixpkgs:nixpkgs.bzl&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;nixpkgs_local_repository&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
nixpkgs_local_repository&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;nixpkgs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    nix_file &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;default.nix&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now you can define a GHC toolchain for &lt;code class=&quot;language-text&quot;&gt;rules_haskell&lt;/code&gt; that uses the Nix built
GHC defined above. Note how we declare that this toolchain has a static RTS and
is configured for fully static linking. Add the following lines to your
&lt;code class=&quot;language-text&quot;&gt;WORKSPACE&lt;/code&gt; file.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;load&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;@rules_haskell//haskell:nixpkgs.bzl&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;haskell_register_ghc_nixpkgs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
haskell_register_ghc_nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    version &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;X.Y.Z&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;# Make sure this matches the GHC version.&lt;/span&gt;
    attribute_path &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;staticHaskell.ghc&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    repositories &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;nixpkgs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;@nixpkgs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    static_runtime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    fully_static_link &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GHC relies on the C compiler and linker during compilation. &lt;code class=&quot;language-text&quot;&gt;rules_haskell&lt;/code&gt;
will always use the C compiler and linker provided by the active Bazel C
toolchain. We need to make sure that we use a musl-based C toolchain as well.
Here we will use the same Nix-provided C toolchain that is used by
static-haskell-nix to build GHC.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;load&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;@io_tweag_rules_nixpkgs//nixpkgs:nixpkgs.bzl&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;nixpkgs_cc_configure&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
nixpkgs_cc_configure&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    repository &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;@nixpkgs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    nix_file_content &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token triple-quoted-string string&quot;&gt;&quot;&quot;&quot;
      with import &amp;lt;nixpkgs&amp;gt; { config = {}; overlays = []; }; buildEnv {
        name = &quot;bazel-cc-toolchain&quot;;
        paths = [ staticHaskell.stdenv.cc staticHaskell.binutils ];
      }
    &quot;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, everything is configured for fully static linking. You can define a
Bazel target for a fully statically linked Haskell binary as follows.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;haskell_binary&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;example&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    srcs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Main.hs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    features &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;fully_static_link&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can build your binary and confirm that it is fully statically linked as follows.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ bazel build //:example
$ ldd bazel-bin/example
      not a dynamic executable&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;If you’re interested in further exploring the benefits of fully statically linked
binaries, you might &lt;a href=&quot;https://rules-haskell.readthedocs.io/en/latest/haskell-use-cases.html#containerization-with-rules-docker&quot;&gt;combine them with &lt;code class=&quot;language-text&quot;&gt;rules_docker&lt;/code&gt;&lt;/a&gt; (e.g. through its
&lt;code class=&quot;language-text&quot;&gt;container_image&lt;/code&gt; rule) to build Docker images as Habito have done. With
a rich enough set of Bazel rules and dependency specifications, it’s possible
to reduce your build and deployment workflow to a &lt;code class=&quot;language-text&quot;&gt;bazel test&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;bazel run&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;The current implementation depends on a Nix-provided GHC toolchain capable of
fully static linking that is imported into Bazel using &lt;code class=&quot;language-text&quot;&gt;rules_nixpkgs&lt;/code&gt;.
However, there is no reason why it shouldn’t be possible to use a GHC
distribution capable of fully static linking that was provided by other means,
for example a Docker image such as &lt;a href=&quot;https://github.com/utdemir/ghc-musl&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;ghc-musl&lt;/code&gt;&lt;/a&gt;. Get in touch if you
would like to create fully statically linked Haskell binaries with Bazel but
can’t or don’t want to integrate Nix into your build. Contributions are
welcome!&lt;/p&gt;
&lt;p&gt;We thank Habito for their contributions to &lt;code class=&quot;language-text&quot;&gt;rules_haskell&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;  &lt;a href=&quot;https://www.habito.com/&quot;&gt;Habito&lt;/a&gt; is fixing mortgages and making homebuying fit for the
future. Habito gives people tools, jargon-free knowledge and expert support
to help them buy and finance their homes. Built on a rich foundation of
functional programming and other cutting-edge technology, Habito is a long
time user of and contributor to &lt;code class=&quot;language-text&quot;&gt;rules_haskell&lt;/code&gt;.&lt;/p&gt;
&lt;a class=&quot;footnote-backref&quot; href=&quot;https://www.tweag.io/rss-nix.xml#fnref-1&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
	<pubDate>Wed, 30 Sep 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Sander van der Burg: Assigning unique IDs to services in Disnix deployment models</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-1397115249631682228.post-1266939232103509859</guid>
	<link>http://sandervanderburg.blogspot.com/2020/09/assigning-unique-ids-to-services-in.html</link>
	<description>As described in some of my recent blog posts, one of the more advanced features of &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/02/disnix-toolset-for-distributed.html&quot;&gt;Disnix&lt;/a&gt; as well as &lt;a href=&quot;https://sandervanderburg.blogspot.com/2019/11/a-nix-based-functional-organization-for.html&quot;&gt;the experimental Nix process management&lt;/a&gt; framework is to deploy &lt;a href=&quot;https://sandervanderburg.blogspot.com/2016/06/deploying-containers-with-disnix-as.html&quot;&gt;&lt;strong&gt;multiple instances&lt;/strong&gt;&lt;/a&gt; of the same service to the same machine.&lt;br /&gt;&lt;br /&gt;To make running multiple service instances on the same machine possible, these tools rely on &lt;strong&gt;conflict avoidance&lt;/strong&gt; rather than isolation (typically used for &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/07/on-using-nix-and-docker-as-deployment.html&quot;&gt;containers&lt;/a&gt;). To allow multiple services instances to co-exist on the same machine, they need to be configured in such a way that they do not allocate any conflicting resources.&lt;br /&gt;&lt;br /&gt;Although for small systems it is doable to configure multiple instances by hand, this process gets tedious and time consuming for larger and more technologically diverse systems.&lt;br /&gt;&lt;br /&gt;One particular kind of conflicting resource that could be configured automatically are &lt;strong&gt;numeric IDs&lt;/strong&gt;, such as TCP/UDP port numbers, user IDs (UIDs), and group IDs (GIDs).&lt;br /&gt;&lt;br /&gt;In this blog post, I will describe how multiple service instances are configured (in Disnix and the process management framework) and how we can automatically assign unique numeric IDs to them.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Configuring multiple service instances&lt;/h2&gt;&lt;br /&gt;To facilitate conflict avoidance in Disnix and the Nix process management framework, services are configured as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{createManagedProcess, tmpDir}:&lt;br /&gt;{port, instanceSuffix ? &quot;&quot;, instanceName ? &quot;webapp${instanceSuffix}&quot;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  webapp = import ../../webapp;&lt;br /&gt;in&lt;br /&gt;createManagedProcess {&lt;br /&gt;  name = instanceName;&lt;br /&gt;  description = &quot;Simple web application&quot;;&lt;br /&gt;  inherit instanceName;&lt;br /&gt;&lt;br /&gt;  # This expression can both run in foreground or daemon mode.&lt;br /&gt;  # The process manager can pick which mode it prefers.&lt;br /&gt;  process = &quot;${webapp}/bin/webapp&quot;;&lt;br /&gt;  daemonArgs = [ &quot;-D&quot; ];&lt;br /&gt;&lt;br /&gt;  environment = {&lt;br /&gt;    PORT = port;&lt;br /&gt;    PID_FILE = &quot;${tmpDir}/${instanceName}.pid&quot;;&lt;br /&gt;  };&lt;br /&gt;  user = instanceName;&lt;br /&gt;  credentials = {&lt;br /&gt;    groups = {&lt;br /&gt;      &quot;${instanceName}&quot; = {};&lt;br /&gt;    };&lt;br /&gt;    users = {&lt;br /&gt;      &quot;${instanceName}&quot; = {&lt;br /&gt;        group = instanceName;&lt;br /&gt;        description = &quot;Webapp&quot;;&lt;br /&gt;      };&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  overrides = {&lt;br /&gt;    sysvinit = {&lt;br /&gt;      runlevels = [ 3 4 5 ];&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The Nix expression shown above is a nested function that describes how to deploy a simple self-contained REST web application with an embedded HTTP server:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;The &lt;strong&gt;outer function header&lt;/strong&gt; (first line) specifies all common build-time dependencies and configuration properties that the service needs:&lt;br /&gt;    &lt;br /&gt;    &lt;ul&gt;      &lt;li&gt;&lt;i&gt;createManagedProcess&lt;/i&gt; is a function that can be used to &lt;a href=&quot;https://sandervanderburg.blogspot.com/2019/11/a-nix-based-functional-organization-for.html&quot;&gt;define process manager agnostic configurations&lt;/a&gt; that can be translated to configuration files for a variety of process managers (e.g. &lt;i&gt;systemd&lt;/i&gt;, &lt;i&gt;launchd&lt;/i&gt;, &lt;i&gt;supervisord&lt;/i&gt; etc.).&lt;/li&gt;      &lt;li&gt;&lt;i&gt;tmpDir&lt;/i&gt; refers to the temp directory in which temp files are stored.&lt;/li&gt;    &lt;/ul&gt;  &lt;/li&gt;  &lt;li&gt;The &lt;strong&gt;inner function header&lt;/strong&gt; (second line) specifies all instance parameters -- these are the parameters that must be configured in such a way that conflicts with other process instances are avoided:&lt;br /&gt;    &lt;br /&gt;    &lt;ul&gt;      &lt;li&gt;The &lt;i&gt;instanceName&lt;/i&gt; parameter (that can be derived from the &lt;i&gt;instanceSuffix&lt;/i&gt;) is a value used by some of the process management backends (e.g. the ones that invoke the &lt;i&gt;daemon&lt;/i&gt; command) to derive a unique PID file for the process. When running multiple instances of the same process, each of them requires a unique PID file name.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;port&lt;/i&gt; parameter specifies to which TCP port the service binds to. Binding the service to a port that is already taken by another service, causes the deployment of this service to fail.&lt;/li&gt;    &lt;/ul&gt;  &lt;/li&gt;  &lt;li&gt;    In the function &lt;strong&gt;body&lt;/strong&gt;, we invoke the &lt;i&gt;createManagedProcess&lt;/i&gt; function to construct configuration files for all supported process manager backends to run the &lt;i&gt;webapp&lt;/i&gt; process:&lt;br /&gt;    &lt;br /&gt;    &lt;ul&gt;      &lt;li&gt;As explained earlier, the &lt;i&gt;instanceName&lt;/i&gt; is used to configure the &lt;i&gt;daemon&lt;/i&gt; executable in such a way that it allocates a unique PID file.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;process&lt;/i&gt; parameter specifies which executable we need to run, both as a foreground process or daemon.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;daemonArgs&lt;/i&gt; parameter specifies which command-line parameters need to be propagated to the executable when the process should &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/01/writing-well-behaving-daemon-in-c.html&quot;&gt;daemonize on its own&lt;/a&gt;.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;environment&lt;/i&gt; parameter specifies all environment variables. The &lt;i&gt;webapp&lt;/i&gt; service uses these variables for runtime property configuration.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;user&lt;/i&gt; parameter is used to specify that the process should run as an unprivileged user. The &lt;i&gt;credentials&lt;/i&gt; parameter is used to configure the creation of the user account and corresponding user group.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;overrides&lt;/i&gt; parameter is used to override the process manager-agnostic parameters with process manager-specific parameters. For the &lt;i&gt;sysvinit&lt;/i&gt; backend, we configure the runlevels in which the service should run.&lt;/li&gt;    &lt;/ul&gt;  &lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Although the convention shown above makes it possible to avoid conflicts (assuming that all potential conflicts have been identified and exposed as function parameters), these parameters are typically configured manually:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{ pkgs, system&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager ? &quot;sysvinit&quot;&lt;br /&gt;, ...&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir forceDisableUserChange processManager;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  processType = import ../../nixproc/derive-dysnomia-process-type.nix {&lt;br /&gt;    inherit processManager;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp1 = rec {&lt;br /&gt;    name = &quot;webapp1&quot;;&lt;br /&gt;    port = 5000;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;1&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  webapp2 = rec {&lt;br /&gt;    name = &quot;webapp2&quot;;&lt;br /&gt;    port = 5001;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;2&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expression shows both a valid Disnix &lt;strong&gt;services&lt;/strong&gt; as well as a valid &lt;strong&gt;processes&lt;/strong&gt; model that composes two web application process instances that can run concurrently on the same machine by invoking the nested constructor function shown in the previous example:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;Each &lt;i&gt;webapp&lt;/i&gt; instance has its own unique instance name, by specifying a unique numeric &lt;i&gt;instanceSuffix&lt;/i&gt; that gets appended to the service name.&lt;/li&gt;  &lt;li&gt;Every &lt;i&gt;webapp&lt;/i&gt; instance binds to a unique TCP port (5000 and 5001) that should not conflict with system services or other process instances.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;h2&gt;Previous work: assigning port numbers&lt;/h2&gt;&lt;br /&gt;Although configuring two process instances is still manageable, the configuration process becomes more tedious and time consuming when the amount and the kind of processes (each having their own potential conflicts) grow.&lt;br /&gt;&lt;br /&gt;Five years ago, I already identified a resource that could be automatically assigned to services: &lt;strong&gt;port numbers&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;I have created &lt;a href=&quot;https://sandervanderburg.blogspot.com/2015/07/assigning-port-numbers-to-microservices.html&quot;&gt;a very simple port assigner tool&lt;/a&gt; that allows you to specify a global ports pool and a target-specific pool pool. The former is used to assign globally unique port numbers to all services in the network, whereas the latter assigns port numbers that are unique to the target machine where the service is deployed to (this is to cope with the scarcity of port numbers).&lt;br /&gt;&lt;br /&gt;Although the tool is quite useful for systems that do not consist of too many different kinds of components, I ran into a number limitations when I want to manage a more diverse set of services:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;Port numbers are not the only numeric IDs that services may require. When deploying systems that consist of self-contained executables, you typically want to run them as unprivileged users for security reasons. User accounts on most UNIX-like systems require unique &lt;strong&gt;user IDs&lt;/strong&gt;, and the corresponding users' groups require unique &lt;strong&gt;group IDs&lt;/strong&gt;.&lt;/li&gt;  &lt;li&gt;We typically want to manage &lt;strong&gt;multiple&lt;/strong&gt; resource &lt;strong&gt;pools&lt;/strong&gt;, for a variety of reasons. For example, when we have a number of HTTP server instances and a number of database instances, then we may want to pick port numbers in the 8000-9000 range for the HTTP servers, whereas for the database servers we want to use a different pool, such as 5000-6000.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;h2&gt;Assigning unique numeric IDs&lt;/h2&gt;&lt;br /&gt;To address these shortcomings, I have developed a replacement tool that acts as a generic numeric ID assigner.&lt;br /&gt;&lt;br /&gt;This new ID assigner tool works with ID &lt;strong&gt;resource configuration&lt;/strong&gt; files, such as:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;rec {&lt;br /&gt;  ports = {&lt;br /&gt;    min = 5000;&lt;br /&gt;    max = 6000;&lt;br /&gt;    scope = &quot;global&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  uids = {&lt;br /&gt;    min = 2000;&lt;br /&gt;    max = 3000;&lt;br /&gt;    scope = &quot;global&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  gids = uids;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above ID resource configuration file (&lt;i&gt;idresources.nix&lt;/i&gt;) defines three resource pools: &lt;i&gt;ports&lt;/i&gt; is a resource that represents port numbers to be assigned to the webapp processes, &lt;i&gt;uids&lt;/i&gt; refers to user IDs and &lt;i&gt;gids&lt;/i&gt; to group IDs. The group IDs' resource configuration is identical to the users' IDs configuration.&lt;br /&gt;&lt;br /&gt;Each resource attribute refers the following configuration properties:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;The &lt;i&gt;min&lt;/i&gt; value specifies the &lt;strong&gt;minimum&lt;/strong&gt; ID to hand out, &lt;i&gt;max&lt;/i&gt; the &lt;strong&gt;maximum&lt;/strong&gt; ID.&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;scope&lt;/i&gt; value specifies the &lt;strong&gt;scope&lt;/strong&gt; of the resource pool. &lt;i&gt;global&lt;/i&gt; (which is the default option) means that the IDs assigned from this resource pool to services are globally unique for the entire system.&lt;br /&gt;    &lt;br /&gt;    The &lt;i&gt;machine&lt;/i&gt; scope can be used to assign IDs that are unique for the machine where a service is distributed to. When the latter option is used, services that are distributed two separate machines may have the same ID.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;We can adjust the services/processes model in such a way that every service will use dynamically assigned IDs and that each service specifies for which resources it requires a unique ID:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{ pkgs, system&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager ? &quot;sysvinit&quot;&lt;br /&gt;, ...&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  ids = if builtins.pathExists ./ids.nix then (import ./ids.nix).ids else {};&lt;br /&gt;&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir forceDisableUserChange processManager ids;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  processType = import ../../nixproc/derive-dysnomia-process-type.nix {&lt;br /&gt;    inherit processManager;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp1 = rec {&lt;br /&gt;    name = &quot;webapp1&quot;;&lt;br /&gt;    port = ids.ports.webapp1 or 0;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;1&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;ports&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  webapp2 = rec {&lt;br /&gt;    name = &quot;webapp2&quot;;&lt;br /&gt;    port = ids.ports.webapp2 or 0;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;2&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;ports&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above services/processes model, we have made the following changes:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;In the beginning of the expression, we &lt;strong&gt;import&lt;/strong&gt; the dynamically generated &lt;i&gt;ids.nix&lt;/i&gt; expression that provides ID assignments for each resource. If the &lt;i&gt;ids.nix&lt;/i&gt; file does not exists, we generate an empty attribute set. We implement this construction (in which the absence of &lt;i&gt;ids.nix&lt;/i&gt; can be tolerated) to allow the ID assigner to bootstrap the ID assignment process.&lt;/li&gt;  &lt;li&gt;Every hardcoded &lt;i&gt;port&lt;/i&gt; attribute of every service is replaced by a &lt;strong&gt;reference&lt;/strong&gt; to the &lt;i&gt;ids&lt;/i&gt; attribute set that is dynamically generated by the ID assigner tool. To allow the ID assigner to open the services model in the first run, we provide a fallback port value of 0.&lt;/li&gt;  &lt;li&gt;Every service specifies for which resources it &lt;strong&gt;requires&lt;/strong&gt; a unique ID through the &lt;i&gt;requiresUniqueIdsFor&lt;/i&gt; attribute. In the above example, both service instances require unique IDs to assign a port number, user ID to the user and group ID to the group.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;The port assignments are propagated as function parameters to the constructor functions that configure the services (as shown earlier in this blog post).&lt;br /&gt;&lt;br /&gt;We could also implement a similar strategy with the UIDs and GIDs, but a more convenient mechanism is to compose the function that creates the credentials, so that it transparently uses our &lt;i&gt;uids&lt;/i&gt; and &lt;i&gt;gids&lt;/i&gt; assignments.&lt;br /&gt;&lt;br /&gt;As shown in the expression above, the &lt;i&gt;ids&lt;/i&gt; attribute set is also propagated to the constructors expression. The constructors expression indirectly composes the &lt;i&gt;createCredentials&lt;/i&gt; function as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{pkgs, ids ? {}, ...}:&lt;br /&gt;&lt;br /&gt;{&lt;br /&gt;  createCredentials = import ../../create-credentials {&lt;br /&gt;    inherit (pkgs) stdenv;&lt;br /&gt;    inherit ids;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  ...&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The &lt;i&gt;ids&lt;/i&gt; attribute set is propagated to the function that composes the &lt;i&gt;createCredentials&lt;/i&gt; function. As a result, it will automatically assign the UIDs and GIDs in the &lt;i&gt;ids.nix&lt;/i&gt; expression when the user configures a user or group with a name that exists in the &lt;i&gt;uids&lt;/i&gt; and &lt;i&gt;gids&lt;/i&gt; resource pools.&lt;br /&gt;&lt;br /&gt;To make these UIDs and GIDs assignments go smoothly, it is recommended to give a process instance the same process name, instance name, user and group names.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Using the ID assigner tool&lt;/h2&gt;&lt;br /&gt;By combining the ID resources specification with the three Disnix models: a &lt;strong&gt;services model&lt;/strong&gt; (that defines all distributable services, shown above), an &lt;strong&gt;infrastructure model&lt;/strong&gt; (that captures all available target machines) and their properties and a &lt;strong&gt;distribution model&lt;/strong&gt; (that maps services to target machines in the network), we can automatically generate an ids configuration that contains all ID assignments:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;$ dydisnix-id-assign -s services.nix -i infrastructure.nix \&lt;br /&gt;  -d distribution.nix \&lt;br /&gt;  --id-resources idresources.nix --output-file ids.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above command will generate an ids configuration file (&lt;i&gt;ids.nix&lt;/i&gt;) that provides, for each resource in the ID resources model, a unique assignment to services that are distributed to a target machine in the network. (Services that are not distributed to any machine in the distribution model will be skipped, to not waste too many resources).&lt;br /&gt;&lt;br /&gt;The output file (&lt;i&gt;ids.nix&lt;/i&gt;) has the following structure:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{&lt;br /&gt;  &quot;ids&quot; = {&lt;br /&gt;    &quot;gids&quot; = {&lt;br /&gt;      &quot;webapp1&quot; = 2000;&lt;br /&gt;      &quot;webapp2&quot; = 2001;&lt;br /&gt;    };&lt;br /&gt;    &quot;uids&quot; = {&lt;br /&gt;      &quot;webapp1&quot; = 2000;&lt;br /&gt;      &quot;webapp2&quot; = 2001;&lt;br /&gt;    };&lt;br /&gt;    &quot;ports&quot; = {&lt;br /&gt;      &quot;webapp1&quot; = 5000;&lt;br /&gt;      &quot;webapp2&quot; = 5001;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;  &quot;lastAssignments&quot; = {&lt;br /&gt;    &quot;gids&quot; = 2001;&lt;br /&gt;    &quot;uids&quot; = 2001;&lt;br /&gt;    &quot;ports&quot; = 5001;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;The &lt;i&gt;ids&lt;/i&gt; attribute contains for each resource (defined in the ID resources model) the unique ID assignments per service. As shown earlier, both service instances require unique IDs for &lt;i&gt;ports&lt;/i&gt;, &lt;i&gt;uids&lt;/i&gt; and &lt;i&gt;gids&lt;/i&gt;. The above attribute set stores the corresponding ID assignments.&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;lastAssignments&lt;/i&gt; attribute memorizes the last ID assignment per resource. Once an ID is assigned, it will not be immediately reused. This is to allow roll backs and to prevent data to incorrectly get owned by the wrong user accounts. Once the maximum ID limit is reached, the ID assigner will start searching for a free assignment from the beginning of the resource pool.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;In addition to assigning IDs to services that are distributed to machines in the network, it is also possible to assign IDs to all services (regardless whether they have been deployed or not):&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;$ dydisnix-id-assign -s services.nix \&lt;br /&gt;  --id-resources idresources.nix --output-file ids.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Since the above command does not know anything about the target machines, it only works with an ID resources configuration that defines global scope resources.&lt;br /&gt;&lt;br /&gt;When you intend to upgrade an existing deployment, you typically want to retain already assigned IDs, while obsolete ID assignment should be removed, and new IDs should be assigned to services that have none yet. This is to prevent unnecessary redeployments.&lt;br /&gt;&lt;br /&gt;When removing the first webapp service and adding a third instance:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{ pkgs, system&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager ? &quot;sysvinit&quot;&lt;br /&gt;, ...&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  ids = if builtins.pathExists ./ids.nix then (import ./ids.nix).ids else {};&lt;br /&gt;&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir forceDisableUserChange processManager ids;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  processType = import ../../nixproc/derive-dysnomia-process-type.nix {&lt;br /&gt;    inherit processManager;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp2 = rec {&lt;br /&gt;    name = &quot;webapp2&quot;;&lt;br /&gt;    port = ids.ports.webapp2 or 0;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;2&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;ports&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;  &lt;br /&gt;  webapp3 = rec {&lt;br /&gt;    name = &quot;webapp3&quot;;&lt;br /&gt;    port = ids.ports.webapp3 or 0;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;3&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;ports&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;And running the following command (that provides the current &lt;i&gt;ids.nix&lt;/i&gt; as a parameter):&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix -s services.nix -i infrastructure.nix -d distribution.nix \&lt;br /&gt;  --id-resources idresources.nix --ids ids.nix --output-file ids.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;we will get the following ID assignment configuration:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{&lt;br /&gt;  &quot;ids&quot; = {&lt;br /&gt;    &quot;gids&quot; = {&lt;br /&gt;      &quot;webapp2&quot; = 2001;&lt;br /&gt;      &quot;webapp3&quot; = 2002;&lt;br /&gt;    };&lt;br /&gt;    &quot;uids&quot; = {&lt;br /&gt;      &quot;webapp2&quot; = 2001;&lt;br /&gt;      &quot;webapp3&quot; = 2002;&lt;br /&gt;    };&lt;br /&gt;    &quot;ports&quot; = {&lt;br /&gt;      &quot;webapp2&quot; = 5001;&lt;br /&gt;      &quot;webapp3&quot; = 5002;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;  &quot;lastAssignments&quot; = {&lt;br /&gt;    &quot;gids&quot; = 2002;&lt;br /&gt;    &quot;uids&quot; = 2002;&lt;br /&gt;    &quot;ports&quot; = 5002;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;As may be observed, since the &lt;i&gt;webapp2&lt;/i&gt; process is in both the current and the previous configuration, its ID assignments will be retained. &lt;i&gt;webapp1&lt;/i&gt; gets removed because it is no longer in the services model. &lt;i&gt;webapp3&lt;/i&gt; gets the next numeric IDs from the resources pools.&lt;br /&gt;&lt;br /&gt;Because the configuration of &lt;i&gt;webapp2&lt;/i&gt; stays the same, it does not need to be redeployed.&lt;br /&gt;&lt;br /&gt;The models shown earlier are valid Disnix services models. As a consequence, they can be used with Dynamic Disnix's ID assigner tool: &lt;i&gt;dydisnix-id-assign&lt;/i&gt;.&lt;br /&gt;&lt;br /&gt;Although these Disnix services models are also valid processes models (used by the Nix process management framework) not every processes model is guaranteed to be compatible with a Disnix service model.&lt;br /&gt;&lt;br /&gt;For process models that are not compatible, it is possible to use the &lt;i&gt;nixproc-id-assign&lt;/i&gt; tool that acts as a wrapper around &lt;i&gt;dydisnix-id-assign&lt;/i&gt; tool:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nixproc-id-assign --id-resources idresources.nix processes.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Internally, the &lt;i&gt;nixproc-id-assign&lt;/i&gt; tool converts a processes model to a Disnix service model (augmenting the process instance objects with missing properties) and propagates it to the &lt;i&gt;dydisnix-id-assign&lt;/i&gt; tool.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;A more advanced example&lt;/h2&gt;&lt;br /&gt;The &lt;i&gt;webapp&lt;/i&gt; processes example is fairly trivial and only needs unique IDs for three kinds of resources: port numbers, UIDs, and GIDs.&lt;br /&gt;&lt;br /&gt;I have also developed a more complex example for the Nix process management framework that exposes several commonly used system services on Linux systems, such as:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{ pkgs ? import &amp;lt;nixpkgs&amp;gt; { inherit system; }&lt;br /&gt;, system ? builtins.currentSystem&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  ids = if builtins.pathExists ./ids.nix then (import ./ids.nix).ids else {};&lt;br /&gt;&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir cacheDir forceDisableUserChange processManager ids;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  apache = rec {&lt;br /&gt;    port = ids.httpPorts.apache or 0;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.simpleWebappApache {&lt;br /&gt;      inherit port;&lt;br /&gt;      serverAdmin = &quot;root@localhost&quot;;&lt;br /&gt;    };&lt;br /&gt;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;httpPorts&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  postgresql = rec {&lt;br /&gt;    port = ids.postgresqlPorts.postgresql or 0;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.postgresql {&lt;br /&gt;      inherit port;&lt;br /&gt;    };&lt;br /&gt;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;postgresqlPorts&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  influxdb = rec {&lt;br /&gt;    httpPort = ids.influxdbPorts.influxdb or 0;&lt;br /&gt;    rpcPort = httpPort + 2;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.simpleInfluxdb {&lt;br /&gt;      inherit httpPort rpcPort;&lt;br /&gt;    };&lt;br /&gt;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;influxdbPorts&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above processes model exposes three service instances: an Apache HTTP server (that works with a simple configuration that serves web applications from a single virtual host), PostgreSQL and InfluxDB. Each service requires a unique user ID and group ID so that their privileges are separated.&lt;br /&gt;&lt;br /&gt;To make these services more accessible/usable, we do not use a shared ports resource pool. Instead, each service type consumes port numbers from their own resource pools.&lt;br /&gt;&lt;br /&gt;The following ID resources configuration can be used to provision the unique IDs to the services above:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;rec {&lt;br /&gt;  uids = {&lt;br /&gt;    min = 2000;&lt;br /&gt;    max = 3000;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  gids = uids;&lt;br /&gt;&lt;br /&gt;  httpPorts = {&lt;br /&gt;    min = 8080;&lt;br /&gt;    max = 8085;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  postgresqlPorts = {&lt;br /&gt;    min = 5432;&lt;br /&gt;    max = 5532;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  influxdbPorts = {&lt;br /&gt;    min = 8086;&lt;br /&gt;    max = 8096;&lt;br /&gt;    step = 3;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above ID resources configuration defines a shared UIDs and GIDs resource pool, but separate ports resource pools for each service type. This has the following implications if we deploy multiple instances of each service type:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;All Apache HTTP server instances get a TCP port assignment between 8080-8085.&lt;/li&gt;  &lt;li&gt;All PostgreSQL server instances get a TCP port assignment between 5432-5532.&lt;/li&gt;  &lt;li&gt;All InfluxDB server instances get a TCP port assignment between 8086-8096. Since an InfluxDB allocates two port numbers: one for the HTTP server and one for the RPC service (the latter's port number is the base port number + 2). We use a step count of 3 so that we can retain this convention for each InfluxDB instance.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;br /&gt;In this blog post, I have described a new tool: &lt;i&gt;dydisnix-id-assign&lt;/i&gt; that can be used to automatically assign unique numeric IDs to services in Disnix service models.&lt;br /&gt;&lt;br /&gt;Moreover, I have described: &lt;i&gt;nixproc-id-assign&lt;/i&gt; that acts a thin wrapper around this tool to automatically assign numeric IDs to services in the Nix process management framework's processes model.&lt;br /&gt;&lt;br /&gt;This tool replaces the old &lt;i&gt;dydisnix-port-assign&lt;/i&gt; tool in the &lt;a href=&quot;https://sandervanderburg.blogspot.com/2016/08/an-extended-self-adaptive-deployment.html&quot;&gt;Dynamic Disnix toolset&lt;/a&gt; (described in the blog post written five years ago) that is much more limited in its capabilities.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Availability&lt;/h2&gt;&lt;br /&gt;The &lt;i&gt;dydisnix-id-assign&lt;/i&gt; tool is available in the current development version of &lt;a href=&quot;https://github.com/svanderburg/dydisnix&quot;&gt;Dynamic Disnix&lt;/a&gt;. The &lt;i&gt;nixproc-id-assign&lt;/i&gt; is part of the current implementation of the &lt;a href=&quot;https://github.com/svanderburg/nix-processmgmt&quot;&gt;Nix process management framework prototype&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;</description>
	<pubDate>Thu, 24 Sep 2020 18:24:00 +0000</pubDate>
	<author>noreply@blogger.com (Sander van der Burg)</author>
</item>
<item>
	<title>Tweag I/O: Implicit Dependencies in Build Systems</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-09-16-implicit-build-dependencies/</guid>
	<link>https://tweag.io/blog/2020-09-16-implicit-build-dependencies/</link>
	<description>&lt;p&gt;In making a build system for your software, you codified the dependencies
between its parts. But, did you account for &lt;em&gt;implicit&lt;/em&gt; software dependencies,
like system libraries and compiler toolchains?&lt;/p&gt;
&lt;p&gt;Implicit dependencies give rise to the biggest and most common problem with
software builds - the lack of &lt;em&gt;hermiticity&lt;/em&gt;. Without hermetic builds,
&lt;em&gt;reproducibility&lt;/em&gt; and &lt;em&gt;cacheability&lt;/em&gt; are lost.&lt;/p&gt;
&lt;p&gt;This post motivates the desire for reproducibility and cacheability, and
explains how we achieve hermetic, reproducible, highly cacheable builds by
taking control of implicit dependencies.&lt;/p&gt;
&lt;h3&gt;Reproducibility&lt;/h3&gt;
&lt;p&gt;Consider a developer newly approaching a code repository. After cloning the
repo, the developer must install a long list of “build requirements” and plod
through multiple steps of “setup”, only to find that, yes indeed, the build
fails. Yet, it worked just fine for their colleague! The developer, typically
not expert in build tooling, must debug the mysterious failure not of their
making. This is bad for morale and for productivity.&lt;/p&gt;
&lt;p&gt;This happens because the build is not &lt;em&gt;reproducible&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;One very common reason for the failure is that the compiler toolchain on the
developer’s system is different from that of the colleague. This happens even
with build systems that use sophisticated build software, like &lt;a href=&quot;https://www.tweag.io/blog/tags/bazel&quot;&gt;Bazel&lt;/a&gt;.
Bazel implicitly uses whatever system libraries and compilers are currently
installed in the developer’s environment.&lt;/p&gt;
&lt;p&gt;A common workaround is to provide developers with a Docker image equipped with
a certain compiler toolchain and system libraries, and then to mandate that the
Bazel build occurs in that context.&lt;/p&gt;
&lt;p&gt;That solution has a number of drawbacks. First, if the developer is using
macOS, the virtualized build context runs substantially slower. Second, the
Bazel build cache, developer secrets, and the source code remain outside of the
image and this adds complexity to the Docker invocation. Third, the Docker
image must be rebuilt and redistributed as dependencies change and that’s extra
maintenance. Fourth, and this is the biggest issue, Docker image builds are
themselves not reproducible - they nearly always rely on some external state
that does not remain constant across build invocations, and that means the
build can fail for reasons unrelated to the developer’s code.&lt;/p&gt;
&lt;p&gt;A better solution is to use &lt;a href=&quot;https://www.tweag.io/blog/tags/nix&quot;&gt;Nix&lt;/a&gt; to supply the compiler toolchain and
system library dependencies. Nix is a software package management system
somewhat like Debian’s APT or macOS’s Homebrew. Nix goes much farther to help
developers control their environments. It is unsurpassed when it comes to
reproducible builds of software packages.&lt;/p&gt;
&lt;p&gt;Nix facilitates use of the Nixpkgs package set. That set is &lt;a href=&quot;https://repology.org/repositories/statistics/nonunique&quot;&gt;the largest single
set of software packages&lt;/a&gt;. It is also the &lt;a href=&quot;https://repology.org/repositories/statistics/newest&quot;&gt;freshest&lt;/a&gt; package set. It
provides build instructions that work both on Linux and macOS. Developers can
easily pin any software package at an exact version.&lt;/p&gt;
&lt;p&gt;Learn more about &lt;a href=&quot;https://www.tweag.io/blog/2018-03-15-bazel-nix/&quot;&gt;using Nix with Bazel, here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Cacheability&lt;/h3&gt;
&lt;p&gt;Not only should builds be reproducible, but they should also be fast. Fast
builds are achieved by caching intermediate build results. Cache entries are
keyed based on the precise dependencies as well as the build instructions that
produce the entries. Builds will only benefit from a (shared, distributed)
cache when they have matching dependencies. Otherwise, cache keys (which depend
on the precise dependencies) will be different, and there will be cache misses.
This means that the developer will have to rebuild targets locally. These
unnecessary local rebuilds slow development.&lt;/p&gt;
&lt;p&gt;The solution is to &lt;a href=&quot;https://www.tweag.io/blog/2018-03-15-bazel-nix/&quot;&gt;make the implicit dependencies into explicit ones, again
using Nix&lt;/a&gt;, making sure to configure and use a shared Nix cache.&lt;/p&gt;
&lt;p&gt;Learn more about &lt;a href=&quot;https://www.tweag.io/blog/2020-04-09-bazel-remote-cache/&quot;&gt;configuring a shared Bazel cache, here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;It is important to eliminate implicit dependencies in your build system in
order to retain build reproducibility and cacheability. Identify Nix packages
that can replace the implicit dependencies of your Bazel build and use
&lt;a href=&quot;https://github.com/tweag/rules_nixpkgs&quot;&gt;rules_nixpkgs&lt;/a&gt; to declare them as explicit dependencies. That will yield a
fast, correct, hermetic build.&lt;/p&gt;</description>
	<pubDate>Wed, 16 Sep 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Tweag I/O: Towards a content-addressed model for Nix</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-09-10-nix-cas/</guid>
	<link>https://tweag.io/blog/2020-09-10-nix-cas/</link>
	<description>&lt;p&gt;This is my first post about content-addressability in Nix — a long-awaited feature that is hopefully coming soon!
In this post I will show you how this feature will improve the Nix
infrastructure. I’ll come back in another post to explain the technical challenges of
adding content-addressability to Nix.&lt;/p&gt;
&lt;p&gt;Nix has a wonderful model for handling packages.
Because each derivation is stored under (aka &lt;em&gt;addressed by&lt;/em&gt;) a unique
name, multiple versions of the same library can coexist on the same
system without issues: each version of the library has a distinct
name, as far as Nix is concerned.&lt;/p&gt;
&lt;p&gt;What’s more, if &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; is upgraded in &lt;a href=&quot;https://github.com/NixOS/nixpkgs/&quot;&gt;Nixpkgs&lt;/a&gt;, Nix knows that all the
packages that depend on &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; (i.e., almost everything) must be
rebuilt, if only so that they point at the name of the new &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt;
version. This way, a Nix installation will never feature a package
built for one version of &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt;, but dynamically linked against
another: as a user, it means that you will never have an &lt;em&gt;undefined
symbol&lt;/em&gt; error. Hurray!&lt;/p&gt;
&lt;h2&gt;The input-addressed store&lt;/h2&gt;
&lt;p&gt;How does Nix achieve this feat? The idea is that the name of a package
is derived from all of its inputs (that is, the complete list of
dependencies, as well as the package description). So if you change
the git tag from which &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; is fetched, the name changes, if the
name of &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; changes, then the name of any package which has &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; in
its dependencies changes.&lt;/p&gt;
&lt;p&gt;However this can be very pessimistic: even changes that aren’t
semantically meaningful can imply mass rebuilding and downloading. As
a slightly extreme example, &lt;a href=&quot;https://github.com/NixOS/nixpkgs/pull/83446&quot;&gt;this merge-request on
Nixpkgs&lt;/a&gt; makes a tiny change to the way &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; is built. It doesn’t actually
change &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt;, yet requires rebuilding an insane amount of
packages. Because, as far as Nix is concerned, all these packages have
different names, hence are different packages. In reality, though,
they weren’t.&lt;/p&gt;
&lt;p&gt;Nevertheless, the cost of the rebuild has to be born by the Nix
infrastructure: &lt;a href=&quot;https://hydra.nixos.org&quot;&gt;Hydra&lt;/a&gt; builds all packages to populate the cache,
and all the newly built packages must be stored. It costs both time,
and money (in cpu power, and storage space).&lt;/p&gt;
&lt;h2&gt;Unnecessary rebuilds?&lt;/h2&gt;
&lt;p&gt;Most distributions, by default, don’t rebuild packages when their dependencies change, and have a (more-or-less automated) process to detect changes that require rebuilding reverse dependencies.
For example, Debian &lt;a href=&quot;https://www.debian.org/doc/debian-policy/policy.pdf#81&quot;&gt;tries to detect ABI changes automatically&lt;/a&gt; and Fedora has a &lt;a href=&quot;https://docs.fedoraproject.org/en-US/fesco/Updates_Policy/&quot;&gt;more manual process&lt;/a&gt;.
But Nix doesn’t.&lt;/p&gt;
&lt;p&gt;The issue is that the notion of a “breaking change” is a very fuzzy one.
Should we follow Debian and consider that only ABI changes are breaking?
This criterion only applies for shared libraries, and as the Debian policy acknowledges, only for “well-behaved” programs.
So if we follow this criterion, there’s still need for manual curation, which is &lt;strong&gt;precisely&lt;/strong&gt; what Nix tries to avoid.&lt;/p&gt;
&lt;h2&gt;The content-addressed model&lt;/h2&gt;
&lt;p&gt;Quite happily, there is a criterion to avoid many useless rebuilds without sacrificing correctness: detecting when changes in a package (or one of its dependencies) yields the exact same output.
That might seem like an edge case, but the &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; example above (and many others) shows that there’s a practical application to it.
As another example, &lt;code class=&quot;language-text&quot;&gt;go&lt;/code&gt; depends on &lt;code class=&quot;language-text&quot;&gt;perl&lt;/code&gt; for its tests, so an upgrade of &lt;code class=&quot;language-text&quot;&gt;perl&lt;/code&gt; requires rebuilding all the Go packages in Nixpkgs, although it most likely doesn’t change the output of the &lt;code class=&quot;language-text&quot;&gt;go&lt;/code&gt; derivation.&lt;/p&gt;
&lt;p&gt;But, for Nix to recognise that a package is not a new package, the
new, unchanged, &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; or &lt;code class=&quot;language-text&quot;&gt;go&lt;/code&gt; packages must have &lt;em&gt;the same name&lt;/em&gt;
as the old version. Therefore, the name of a package must not be
derived from its inputs which have changed, but, instead, it should be
derived from the content of the compiled package. This is called
content addressing.&lt;/p&gt;
&lt;p&gt;Content addressing is how you can be sure that when you and a
colleague at the other side of the world type &lt;code class=&quot;language-text&quot;&gt;git checkout 7cc16bb8cd38ff5806e40b32978ae64d54023ce0&lt;/code&gt; you actually have the exact
same content in your tree. Git commits are content addressed, therefore the name
&lt;code class=&quot;language-text&quot;&gt;7cc16bb8cd38ff5806e40b32978ae64d54023ce0&lt;/code&gt; refers to that exact
tree.&lt;/p&gt;
&lt;p&gt;Yet another example of content-addressed storage is &lt;a href=&quot;https://ipfs.io/&quot;&gt;IPFS&lt;/a&gt;. In IPFS storage
files can be stored in any number of computers, and even moved from
computer to computer. The content-derived name is used as a way to give
an intrinsic name to a file, regardless of where it is stored.&lt;/p&gt;
&lt;p&gt;In fact, even the particular use case that we are discussing here -
avoiding recompilation when a rebuilt dependency hasn’t changed -
can be found in various build systems such as
&lt;a href=&quot;https://bazel.build/&quot;&gt;Bazel&lt;/a&gt;. In build systems, such recompilation
avoidance is sometimes known as the &lt;em&gt;early cutoff optimization&lt;/em&gt; −
see the &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf&quot;&gt;build systems a la carte paper&lt;/a&gt;
for example).&lt;/p&gt;
&lt;p&gt;So all we need to do is to move the Nix store from an input-addressed
model to a content-addressed model, as used by many tools
already, and we will be able to save a lot of storage space and CPU
usage, by rebuilding many fewer packages. Nixpkgs contributors will
see their CI time improved. It could also allow &lt;a href=&quot;https://github.com/NixOS/nix/issues/859&quot;&gt;serving a binary cache
over IPFS&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Well, like many things with computers,
this is actually way harder than it sounds (which explains why this
hasn’t already been done despite being discussed nearly 15 years ago in the
&lt;a href=&quot;https://github.com/edolstra/edolstra.github.io/raw/49a78323f6b319da6e078b4f5f6b3112a30e8db9/pubs/phd-thesis.pdf&quot;&gt;original paper&lt;/a&gt;), but we now believe that there’s &lt;a href=&quot;https://github.com/NixOS/rfcs/pull/62&quot;&gt;a way forward&lt;/a&gt;… more on that in a later post.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;A content-addressed store for Nix would help reduce the insane load
that &lt;a href=&quot;https://hydra.nixos.org&quot;&gt;Hydra&lt;/a&gt; has to sustain. While content-addressing is a common technique both in distributed systems
and build systems (Nix is both!), getting to the point where it was
feasible to integrate content-addressing in Nix has been a long journey.&lt;/p&gt;
&lt;p&gt;In a future post, I’ll explain why it was so hard, and how we finally
managed to propose a viable design for a content-addressed Nix.&lt;/p&gt;</description>
	<pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>nixbuild.net: nixbuild.net is Generally Available</title>
	<guid isPermaLink="true">https://blog.nixbuild.net/posts/2020-08-28-nixbuild-net-is-generally-available.html</guid>
	<link>https://blog.nixbuild.net/posts/2020-08-28-nixbuild-net-is-generally-available.html</link>
	<description>&lt;p&gt;Today, &lt;a href=&quot;https://nixbuild.net&quot;&gt;nixbuild.net&lt;/a&gt; is exiting private beta and made generally available! Anyone can now &lt;a href=&quot;https://nixbuild.net#register&quot;&gt;sign up&lt;/a&gt; for a nixbuild.net account and immediately start building using the free CPU hours included with every account.&lt;/p&gt;
&lt;p&gt;After the free CPU hours have been consumed, the pricing is simple: 0.12 EUR (excl. VAT) per CPU hour consumed, billed monthly.&lt;/p&gt;

&lt;p&gt;As part of this GA announcement, a number of marketing and documentation improvements have been published:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A much improved and redesigned landing page at &lt;a href=&quot;https://nixbuild.net&quot;&gt;https://nixbuild.net&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An extensive &lt;a href=&quot;https://nixbuild.net#faq&quot;&gt;FAQ&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A reworked &lt;a href=&quot;https://docs.nixbuild.net/getting-started&quot;&gt;Getting Started&lt;/a&gt; guide&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Proper documentation of the &lt;a href=&quot;https://docs.nixbuild.net/nixbuild-shell&quot;&gt;nixbuild.net shell&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;We’re really happy for nixbuild.net to enter this new phase — making simple, performant and scalable remote builds available to every Nix user! We’re excited to see how the service is used, and we have lots of plans for the future of nixbuild.net.&lt;/strong&gt;&lt;/p&gt;</description>
	<pubDate>Fri, 28 Aug 2020 00:00:00 +0000</pubDate>
	<author>support@nixbuild.net (nixbuild.net)</author>
</item>
<item>
	<title>Tweag I/O: How Nix grew a marketing team</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-08-20-how-nix-grew-a-marketing-team/</guid>
	<link>https://tweag.io/blog/2020-08-20-how-nix-grew-a-marketing-team/</link>
	<description>&lt;p&gt;Recently I witnessed the moment when a potential Nix user reached eureka.
The moment where everything regarding Nix made sense.
My friend, now a Nix user, screamed from joy: &lt;strong&gt;“We need to Nix–ify everything!”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Moments like these reinforce my belief that Nix is a solution from — and for — the future.
A solution that could reach many more people, only if learning about Nix didn’t demand investing as much time and effort as it does now.&lt;/p&gt;
&lt;p&gt;I think that Nix has the perfect foundation for becoming a success but that it still needs better &lt;em&gt;marketing&lt;/em&gt;.
Many others agree with me, and that’s why we formed the &lt;a href=&quot;https://nixos.org/teams/marketing.html&quot;&gt;Nix marketing team&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I would like to convince you that indeed, marketing is the way to go and that it is worth it.
Therefore, in this post I will share my thoughts on what kind of success we aim for, and which marketing efforts we are currently pursuing.
The marketing team is already giving its first results, and with your input, we can go further.&lt;/p&gt;
&lt;h2&gt;What does success look like?&lt;/h2&gt;
&lt;p&gt;At the time of writing this post, I have been using Nix for 10 years.
I organized one and attended most of the Nix conferences since then, and talked to many people in the community.
All of this does not give me the authority to say what success for Nix looks like, but it does give me a great insight into what we — the Nix community — can agree on.&lt;/p&gt;
&lt;p&gt;Success for Nix would be the next time you encounter a project on GitHub, it would already contain a &lt;code class=&quot;language-text&quot;&gt;default.nix&lt;/code&gt; for you to start developing.
Success for Nix would be the next time you try to run a server on the cloud, NixOS would be offered to you.
Or even more ambitious, would be other communities recognising Nix as a &lt;em&gt;de facto&lt;/em&gt; standard that improves the industry as a whole.&lt;/p&gt;
&lt;p&gt;To some, this success statement may seem very obvious.
However, it is important to say it out loud and often, so we can keep focus, and keep working on the parts of Nix that will contribute the most to this success.&lt;/p&gt;
&lt;h2&gt;The importance of marketing&lt;/h2&gt;
&lt;p&gt;Before we delve into what Nix still lacks, I would like to say that we — engineers and developers — should be aware of our bias against marketing.
This bias becomes clear when we think about what we think are the defining aspects for a project’s success.
We tend to believe that code is everything, and that good code leads to good results.
But what if I tell you that good marketing constitutes more than 50% of the success of a project?
Would you be upset?
We have to overcome this bias, since it prevents us from seeing the big picture.&lt;/p&gt;
&lt;p&gt;Putting aside those Sunday afternoons when I code for the pure joy of stretching my mind, most of the time I simply want to solve a problem.
The joy when seeing others realizing that their problem is not a problem anymore, is one of the best feelings I experienced as a developer.
This is what drives me.
Not the act of coding itself, but the act of solving the problem.
Coding is then only part of the solution.
Others need to know about the existence of your code, understand how it can solve their problem and furthermore they need to know how to use it.&lt;/p&gt;
&lt;p&gt;That is why marketing, and, more generally, non-technical work, is at least as important as technical work.
Documentation, writing blog posts, creating content for the website, release announcements, conference talks, conference booths, forums, chat channels, email lists, demo videos, use cases, swag, search engine optimisation, social media presence, engaging with the community…
These are all crucial parts of any successful project.&lt;/p&gt;
&lt;p&gt;Nix needs better marketing, from a better website to better documentation, along with all the ingredients mentioned above.
If we want Nix to grow as a project we need to improve our marketing game, since this is the area of work that is historically receiving the least amount of attention.
And we are starting to work on it.
In the middle of March 2020, a bunch of us got together and &lt;a href=&quot;https://discourse.nixos.org/t/marketing-team-can-we-present-nix-nixos-better/6249&quot;&gt;announced&lt;/a&gt; the creation of &lt;a href=&quot;https://nixos.org/teams/marketing.html&quot;&gt;the Nix marketing team&lt;/a&gt;.
Since then we meet roughly every two weeks to discuss and work on non-technical challenges that the Nix project is facing.&lt;/p&gt;
&lt;p&gt;But before the Nix marketing team could start doing any actual work we had to answer an important question:&lt;/p&gt;
&lt;h2&gt;What is Nix?&lt;/h2&gt;
&lt;p&gt;I want to argue that the Nix community is still missing an answer to an apparently very simple question: &lt;em&gt;What is Nix?&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The reason why &lt;em&gt;what is Nix?&lt;/em&gt; is a harder question than it may appear at first, is that any complete answer has to tell us &lt;em&gt;what&lt;/em&gt; and &lt;em&gt;who&lt;/em&gt; Nix is for.
Knowing the audience and primary use cases is a precondition to improving the website, documentation, or even Nix itself.&lt;/p&gt;
&lt;p&gt;This is what the Nix marketing team &lt;a href=&quot;https://www.youtube.com/watch?list=PLt4-_lkyRrOOO8CYo5XPx6UI05q8kwhj0&quot;&gt;discussed first&lt;/a&gt;. We identified the following audiences and primary use cases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Development environments (audience: developers)&lt;/li&gt;
&lt;li&gt;Deploying to the cloud (audience: system administrators)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It doesn’t mean other use cases are not important — they are.
We are just using the primary use cases as a gateway drug into the rest of the Nix’s ecosystem.
In this way, new users will not be overwhelmed with all the existing options and will have a clear idea where to start.&lt;/p&gt;
&lt;p&gt;Some reasons for selecting the two use cases are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Both use cases are relatively polished solutions.
Clearly, there is still much to be improved, but currently these are the two use cases with the best user experience in the Nix ecosystem.&lt;/li&gt;
&lt;li&gt;One use case is a natural continuation of another.
First, you develop and then you can use the same tools to package and deploy.&lt;/li&gt;
&lt;li&gt;Market size for both use cases is huge, which means there is a big potential.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A differentiating factor — why somebody would choose Nix over others — is Nix’s ability to provide reproducible results.
The promise of reproducibility is the aspect that already attracts the majority of Nix’s user base.
From this, we came up with a slogan for Nix:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reproducible builds and deploys&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;With the basic question answered we started working.&lt;/p&gt;
&lt;h2&gt;What has been done so far? How can I help?&lt;/h2&gt;
&lt;p&gt;So far, the Marketing team focused on improving the website:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Moved the website to Netlify.&lt;/strong&gt;
The important part is not switching to Netlify, but separating the website from the Nix infrastructure.
This removes the fear of a website update bringing down parts of Nix infrastructure.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Simplified navigation.&lt;/strong&gt;
If you remember, the navigation was different for each project that was listed on the website.
We removed the project differentiation and unified navigation.
This will show Nix ecosystem as a unified story and not a collection of projects.
One story is easier to follow than five.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Created a new learn page.&lt;/strong&gt;
Discoverability of documentation was a huge problem.
Links to popular topics in manuals are now more visible.
Some work on entry level tutorials has also started.
Good and beginner friendly learning resources are what is going to create the next generation of Nix users.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Created new team pages.&lt;/strong&gt;
We collected information about different official and less official teams working on Nix.
The work here is not done, but it shows that many teams don’t have clear responsibilities.
It shows how decisions are made and invites new Nix users to become more involved with the project.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Improved landing page.&lt;/strong&gt;
Instead of telling the user what Nix is, they will experience it from the start.
The landing page is filled with examples that will convince visitors to give Nix a try.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The work of the marketing team has just started, and there is still a lot to be done.
We are working hard on &lt;a href=&quot;https://github.com/NixOS/nixos-homepage/issues/449&quot;&gt;redesigning the website&lt;/a&gt; and &lt;a href=&quot;https://github.com/NixOS/nixos-homepage/issues/444&quot;&gt;improving the messaging&lt;/a&gt;.
The &lt;a href=&quot;https://github.com/NixOS/nixos-homepage/milestone/1&quot;&gt;roadmap&lt;/a&gt; will tell you more about what to expect next.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;If you wish to help&lt;/strong&gt; come and say hi to &lt;a href=&quot;irc://irc.freenode.net/#nixos-marketing&quot;&gt;#nixos-marketing on irc.freenode.org&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Marketing, and non-technical work, is all too often an afterthought for developers. I really wish it weren’t the case.
Having clearly defined problems, audience and strategy should be as important to us as having clean and tested code.
This is important for Nix. This is important for any project that aims to succeed.&lt;/p&gt;</description>
	<pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>nixbuild.net: Build Reuse in nixbuild.net</title>
	<guid isPermaLink="true">https://blog.nixbuild.net/posts/2020-08-13-build-reuse-in-nixbuild-net.html</guid>
	<link>https://blog.nixbuild.net/posts/2020-08-13-build-reuse-in-nixbuild-net.html</link>
	<description>&lt;p&gt;Performance and cost-effectiveness are core values for nixbuild.net. How do you make a Nix build as performant and cheap as possible? The answer is — by not running it at all!&lt;/p&gt;
&lt;p&gt;This post goes into some detail about the different ways nixbuild.net is able to safely reuse build results. The post gets technical, but the main message is that nixbuild.net really tries to avoid building if it can, in order to save time and money for its users.&lt;/p&gt;

&lt;h2 id=&quot;binary-caches&quot;&gt;Binary Caches&lt;/h2&gt;
&lt;p&gt;The most obvious way of reusing build results is by utilising binary caches, and an &lt;a href=&quot;https://blog.nixbuild.net/posts/2020-04-18-binary-cache-support.html&quot;&gt;earlier blog post&lt;/a&gt; described how this is supported by nixbuild.net. In short, if something has been built on &lt;code&gt;cache.nixos.org&lt;/code&gt;, nixbuild.net can skip building it and just fetch it. It is also possible to configure other binary caches to use, and even treat the builds of specific nixbuild.net users in the same way as a trusted binary cache.&lt;/p&gt;
&lt;h2 id=&quot;no-shared-uploads&quot;&gt;No Shared Uploads&lt;/h2&gt;
&lt;p&gt;As part of the Nix remote build protocol, inputs (dependencies) can be uploaded directly to nixbuild.net. Those inputs are not necessarily trustworty, because we don’t know how they were produced. Therefore, those inputs are only allowed to be used by the user who uploaded them. The exception is if the uploaded input had a signature from a binary cache key, then we allow it to be used by all accounts that trust that specific key. Also, if explicit trust has been setup between two accounts, uploaded paths will be shared.&lt;/p&gt;
&lt;h2 id=&quot;derivation-sharing&quot;&gt;Derivation Sharing&lt;/h2&gt;
&lt;p&gt;Another method of reuse, unique to nixbuild.net, is the sharing of build results between users that don’t necessarily trust each other. It works like this:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;When we receive a build request, we get a &lt;a href=&quot;https://nixos.org/nixos/nix-pills/our-first-derivation.html&quot;&gt;derivation&lt;/a&gt; from the user’s Nix client. In essence, this derivation describes what inputs (dependencies) the build needs, and what commands must be run to produce the build output.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The inputs are described in the derivation simply as a list of store paths (&lt;code&gt;/nix/store/abc&lt;/code&gt;, &lt;code&gt;/nix/store/xyz&lt;/code&gt;). The way the Nix remote build protocol works, those store paths have already been provided to us, either because we already had trusted variants of them in our storage, or because we’ve downloaded them from binary caches, or because the client uploaded them to us.&lt;/p&gt;
&lt;p&gt;In order for us to be able to run the build, we need to map the input store paths to the actual file contents of the inputs. This mapping can actually vary even though store paths are the same. This is because a Nix store path does not depend on the &lt;em&gt;contents&lt;/em&gt; of the path, but rather on the &lt;em&gt;dependencies&lt;/em&gt; of the path. So we can very well have multiple versions of the same store path in our storage, because multiple users might have uploaded differing builds of the same paths.&lt;/p&gt;
&lt;p&gt;Anyhow, we will end up with a mapping that depends entirely on what paths the user is allowed to use. So, two users may build the exact same derivation but get different store-path-to-content mappings.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;At this stage, we store a representation of both the derivation itself, and the mapping described in previous step. Together, these two pieces represent a unique derivation in nixbuild.net’s database.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now, we can build the derivation. The build runs inside an isolated, virtualized sandbox that has no network access and nothing other than its inputs inside its filesystem.&lt;/p&gt;
&lt;p&gt;The sandbox is of course vital for keeping your builds secure, but it has another application, too: If we already have built a specific derivation (with a specific set of input content), this build result can be reused for &lt;em&gt;any&lt;/em&gt; user that comes along and requests a build of the exact same derivation with the exact same set of input content.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We do not yet have any numbers on how big impact this type of build result sharing has in practice. The effectiveness will depend on how reproducible the builds are, and of course also on how many users that are likely to build the same derivations.&lt;/p&gt;
&lt;p&gt;For an organization with a large set of custom packages that want to share binary builds with contributors and users, it could turn out useful. The benefit for users is that they don’t actually have to blindly trust a binary cache but instead can be sure that they get binaries that correspond to the nix derivations they have evaluated.&lt;/p&gt;</description>
	<pubDate>Thu, 13 Aug 2020 00:00:00 +0000</pubDate>
	<author>support@nixbuild.net (nixbuild.net)</author>
</item>
<item>
	<title>Tweag I/O: Developing Python with Poetry &amp; Poetry2nix: Reproducible flexible Python environments</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-08-12-poetry2nix/</guid>
	<link>https://tweag.io/blog/2020-08-12-poetry2nix/</link>
	<description>&lt;p&gt;Most Python projects are in fact &lt;em&gt;polyglot&lt;/em&gt;.
Indeed, many popular libraries on &lt;a href=&quot;https://pypi.org&quot;&gt;PyPi&lt;/a&gt; are Python wrappers around C code.
This applies particularly to popular scientific computing packages, such as &lt;code class=&quot;language-text&quot;&gt;scipy&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;numpy&lt;/code&gt;.
Normally, this is the terrain where Nix shines, but its support for Python projects has often been labor-intensive, requiring lots of manual fiddling and fine-tuning.
One of the reasons for this is that most Python package management tools do not give enough static information about the project, not offering the determinism needed by Nix.&lt;/p&gt;
&lt;p&gt;Thanks to &lt;a href=&quot;https://python-poetry.org/&quot;&gt;Poetry&lt;/a&gt;, this is a problem of the past — its rich lock file offers more than enough information to get Nix running, with minimal manual intervention.
In this post, I will show how to use Poetry, together with &lt;a href=&quot;https://github.com/nix-community/poetry2nix&quot;&gt;Poetry2nix&lt;/a&gt;, to easily manage Python projects with Nix.
I will show how to package a simple Python application both using the existing support for Python in Nixpkgs, and then using Poetry2nix.
This will both show why Poetry2nix is more convenient, and serve as a short tutorial covering its features.&lt;/p&gt;
&lt;h2&gt;Our application&lt;/h2&gt;
&lt;p&gt;We are going to package a simple application, a &lt;a href=&quot;https://flask.palletsprojects.com&quot;&gt;Flask&lt;/a&gt; server with two endpoints: one returning a static string “Hello World” and another returning a resized image.
This application was chosen because:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It can fit into a single file for the purposes of this post.&lt;/li&gt;
&lt;li&gt;Image resizing using Pillow requires the use of native libraries, which is something of a strength of Nix.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The code for it is in the &lt;code class=&quot;language-text&quot;&gt;imgapp/__init__.py&lt;/code&gt; file:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; send_file
&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Flask
&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; io &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; BytesIO
&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; PIL &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Image
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; requests


app &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Flask&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__name__&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;


IMAGE_URL &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;https://farm1.staticflickr.com/422/32287743652_9f69a6e9d9_b.jpg&quot;&lt;/span&gt;
IMAGE_SIZE &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;token decorator annotation punctuation&quot;&gt;@app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;route&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;


&lt;span class=&quot;token decorator annotation punctuation&quot;&gt;@app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;route&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;'/image'&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    r &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; requests&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;get&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;IMAGE_URL&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;not&lt;/span&gt; r&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;status_code &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;raise&lt;/span&gt; ValueError&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string-interpolation&quot;&gt;&lt;span class=&quot;token string&quot;&gt;f&quot;Response code was '&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;r&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;status_code&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;'&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    img_io &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; BytesIO&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    img &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Image&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;BytesIO&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;r&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;content&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    img&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;thumbnail&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;IMAGE_SIZE&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    img&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;save&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;img_io&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;'JPEG'&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; quality&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;70&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    img_io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;seek&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; send_file&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;img_io&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; mimetype&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;'image/jpeg'&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;run&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; __name__ &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    main&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;The status quo for packaging Python with Nix&lt;/h2&gt;
&lt;p&gt;There are two standard techniques for integrating Python projects with Nix.&lt;/p&gt;
&lt;h3&gt;Nix only&lt;/h3&gt;
&lt;p&gt;The first technique uses only Nix for package management, and is described in the &lt;a href=&quot;https://nixos.org/nixpkgs/manual/#python&quot;&gt;Python section&lt;/a&gt; of the Nix manual.
While it works and may look very appealing on the surface, it uses Nix for all package management needs, which comes with some drawbacks:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We are essentially tied to whatever package version Nixpkgs provides for any given dependency.
This can be worked around with overrides, but those can cause version incompatibilities.
This happens often in complex Python projects, such as data science ones, which tend to be very sensitive to version changes.&lt;/li&gt;
&lt;li&gt;We are tied to using packages already in Nixpkgs.
While Nixpkgs has many Python packages already packaged up (around 3000 right now) there are many packages missing — PyPi, the Python Package Index has more than 200000 packages.
This can of course be worked around with overlays and manual packaging, but this quickly becomes a daunting task.&lt;/li&gt;
&lt;li&gt;In a team setting, every team member wanting to add packages needs to buy in to Nix and at least have some experience using and understanding Nix.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;All these factors lead us to a conclusion: we need to embrace Python tooling so we can efficiently work with the entire Python ecosystem.&lt;/p&gt;
&lt;h3&gt;Pip and Pypi2Nix&lt;/h3&gt;
&lt;p&gt;The second standard method tries to overcome the faults above by using a hybrid approach of Python tooling together with Nix code generation.
Instead of writing dependencies manually in Nix, they are extracted from the &lt;code class=&quot;language-text&quot;&gt;requirements.txt&lt;/code&gt; file that users of Pip and Virtualenv are very used to.
That is, from a &lt;code class=&quot;language-text&quot;&gt;requirements.txt&lt;/code&gt; file containing the necessary dependencies:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-txt&quot;&gt;&lt;code class=&quot;language-txt&quot;&gt;requests
pillow
flask&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;we can use &lt;a href=&quot;https://github.com/nix-community/pypi2nix&quot;&gt;pypi2nix&lt;/a&gt; to package our application in a more automatic fashion than before:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;nix-shell -p pypi2nix --run &quot;pypi2nix -r requirements.txt&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, Pip is not a dependency manager and therefore the &lt;code class=&quot;language-text&quot;&gt;requirements.txt&lt;/code&gt; file is not explicit enough — it lacks both exact versions for libraries, and system dependencies.
Therefore, the command above will not produce a working Nix expression.
In order to make pypi2nix work correctly, one has to manually find all dependencies incurred by the use of Pillow:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;nix-shell -p pypi2nix --run &quot;pypi2nix -V 3.8 -E pkgconfig -E freetype -E libjpeg -E openjpeg -E zlib -E libtiff -E libwebp -E tcl -E lcms2 -E xorg.libxcb -r requirements.txt&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will generate a large Nix expression, that will indeed work as expected.
Further use of Pypi2nix is left to the reader, but we can already draw some conclusions about this approach:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Code generation results in huge Nix expressions that can be hard to debug and understand.
These expressions will typically be checked into a project repository, and can get out of sync with actual dependencies.&lt;/li&gt;
&lt;li&gt;It’s very high friction, especially around native dependencies.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Having many large Python projects, I wasn’t satisfied with the status quo around Python package management.
So I looked into what could be done to make the situation better, and which tools could be more appropriate for our use-case.
A potential candidate was &lt;a href=&quot;https://github.com/pypa/pipenv&quot;&gt;Pipenv&lt;/a&gt;, however its dependency
solver and lock file format were difficult to work with.
In particular, Pipenv’s detection of “local” vs “non-local” dependencies did not work properly inside the Nix shell and gave us the wrong dependency graph.
Eventually, I found &lt;a href=&quot;https://python-poetry.org/&quot;&gt;Poetry&lt;/a&gt; and it looked very promising.&lt;/p&gt;
&lt;h2&gt;Poetry and Poetry2nix&lt;/h2&gt;
&lt;p&gt;The &lt;a href=&quot;https://python-poetry.org/docs/&quot;&gt;Poetry package manager&lt;/a&gt; is a relatively recent addition to the Python ecosystem but it is gaining popularity very quickly.
Poetry features a nice CLI with good UX and deterministic builds through lock files.&lt;/p&gt;
&lt;p&gt;Poetry uses &lt;code class=&quot;language-text&quot;&gt;pip&lt;/code&gt; under the hood and, for this reason, inherited some of its shortcomings and lock file design.
I managed to land a few patches in Poetry before the 1.0 release to improve the lock file format, and now it is fit for use in Nix builds.
The result was &lt;a href=&quot;https://github.com/nix-community/poetry2nix&quot;&gt;Poetry2nix&lt;/a&gt;, whose key design goals were:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dead simple API.&lt;/li&gt;
&lt;li&gt;Work with the entire Python ecosystem using regular Python tooling.&lt;/li&gt;
&lt;li&gt;Python developers should not have to be Nix experts, and vice versa.&lt;/li&gt;
&lt;li&gt;Being an expert should allow you to “drop down” into the lower levels of the build and customise it.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Poetry2nix is not a code generation tool — it is implemented in pure Nix.
This fixes many of problems outlined in previous paragraphs, since there is a single point of truth for dependencies and their versions.&lt;/p&gt;
&lt;p&gt;But what about our native dependencies from before?
How does Poetry2nix know about those?
Indeed, Poetry2nix comes with an extensive set of overrides built-in for a lot of common packages, including Pillow.
Users are encouraged to contribute overrides &lt;a href=&quot;https://github.com/nix-community/poetry2nix/blob/master/overrides.nix&quot;&gt;upstream&lt;/a&gt; for popular packages, so everyone can have a better user experience.&lt;/p&gt;
&lt;p&gt;Now, let’s see how Poetry2nix works in practice.&lt;/p&gt;
&lt;h3&gt;Developing with Poetry&lt;/h3&gt;
&lt;p&gt;Let’s start with only our application file above (&lt;code class=&quot;language-text&quot;&gt;imgapp/__init__.py&lt;/code&gt;) and a &lt;code class=&quot;language-text&quot;&gt;shell.nix&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; pkgs &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;nixpkgs&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;

pkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;mkShell &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;

  buildInputs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    pkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;python3
    pkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;poetry
  &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Poetry comes with some nice helpers to create a project, so we run:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;$ poetry init&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And then we’ll add our dependencies:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;$ poetry add requests pillow flask&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We now have two files in the folder:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first one is &lt;code class=&quot;language-text&quot;&gt;pyproject.toml&lt;/code&gt; which not only specifies our dependencies but also replaces &lt;code class=&quot;language-text&quot;&gt;setup.py&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The second is &lt;code class=&quot;language-text&quot;&gt;poetry.lock&lt;/code&gt; which contains our entire pinned Python dependency graph.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For Nix to know which scripts to install in the &lt;code class=&quot;language-text&quot;&gt;bin/&lt;/code&gt; output directory, we also need to add a &lt;code class=&quot;language-text&quot;&gt;scripts&lt;/code&gt; section to &lt;code class=&quot;language-text&quot;&gt;pyproject.toml&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-toml&quot;&gt;&lt;code class=&quot;language-toml&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token table class-name&quot;&gt;tool.poetry&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;imgapp&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;0.1.0&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;description&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;authors&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;adisbladis &amp;lt;adisbladis@gmail.com&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token table class-name&quot;&gt;tool.poetry.dependencies&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;python&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;^3.7&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;requests&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;^2.23.0&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;pillow&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;^7.1.2&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;^1.1.2&quot;&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token table class-name&quot;&gt;tool.poetry.dev-dependencies&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token table class-name&quot;&gt;tool.poetry.scripts&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;imgapp&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;'imgapp:main'&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token table class-name&quot;&gt;build-system&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;requires&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;poetry&amp;gt;=0.12&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;build-backend&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;poetry.masonry.api&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Packaging with Poetry2nix&lt;/h3&gt;
&lt;p&gt;Since Poetry2nix is not a code generation tool but implemented entirely in Nix, this step is trivial.
Create a &lt;code class=&quot;language-text&quot;&gt;default.nix&lt;/code&gt; containing:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; pkgs &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;nixpkgs&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
pkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;poetry2nix&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;mkPoetryApplication &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  projectDir &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token url&quot;&gt;./.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can now invoke &lt;code class=&quot;language-text&quot;&gt;nix-build&lt;/code&gt; to build our package defined in &lt;code class=&quot;language-text&quot;&gt;default.nix&lt;/code&gt;.
Poetry2nix will automatically infer package names, dependencies, meta attributes and more from the Poetry metadata.&lt;/p&gt;
&lt;h3&gt;Manipulating overrides&lt;/h3&gt;
&lt;p&gt;Many overrides for system dependencies are already upstream, but what if some are lacking?
These overrides can be manipulated and extended manually:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;poetry2nix&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;mkPoetryApplication &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    projectDir &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token url&quot;&gt;./.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    overrides &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; poetry2nix&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;overrides&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;withDefaults &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; super&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      foo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; foo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;overridePythonAttrs&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;oldAttrs&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;By embracing both modern Python package management tooling and the Nix language, we can achieve best-in-class user experience for Python developers and Nix developers alike.&lt;/p&gt;
&lt;p&gt;There are ongoing efforts to make Poetry2nix and other Nix Python tooling work better with data science packages like &lt;code class=&quot;language-text&quot;&gt;numpy&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;scipy&lt;/code&gt;.
I believe that Nix may soon rival Conda on Linux and MacOS for data science.&lt;/p&gt;
&lt;p&gt;Python + Nix has a bright future ahead of it!&lt;/p&gt;</description>
	<pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate>
</item>

</channel>
</rss>
